SCRIPT  /usr/share/nvim/runtime/ftplugin/rust.vim
Sourced 1 time
Total time:   0.004034
 Self time:   0.002872

count  total (s)   self (s)
                            " Language:     Rust
                            " Description:  Vim ftplugin for Rust
                            " Maintainer:   Chris Morgan <me@chrismorgan.info>
                            " Last Change:  2024-03-17
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
    1              0.000023 if exists("b:did_ftplugin")
                                finish
    1              0.000002 endif
    1              0.000009 let b:did_ftplugin = 1
                            
                            " vint: -ProhibitAbbreviationOption
    1              0.000009 let s:save_cpo = &cpo
    1              0.000021 set cpo&vim
                            " vint: +ProhibitAbbreviationOption
                            
    1              0.000010 if get(b:, 'current_compiler', '') ==# ''
    1              0.000157     if strlen(findfile('Cargo.toml', '.;')) > 0
    1   0.002922   0.001759         compiler cargo
                                else
                                    compiler rustc
    1              0.000001     endif
    1              0.000001 endif
                            
                            " Variables {{{1
                            
                            " The rust source code at present seems to typically omit a leader on /*!
                            " comments, so we'll use that as our default, but make it easy to switch.
                            " This does not affect indentation at all (I tested it with and without
                            " leader), merely whether a leader is inserted by default or not.
    1              0.000008 if get(g:, 'rust_bang_comment_leader', 0)
                                " Why is the `,s0:/*,mb:\ ,ex:*/` there, you ask? I don't understand why,
                                " but without it, */ gets indented one space even if there were no
                                " leaders. I'm fairly sure that's a Vim bug.
                                setlocal comments=s1:/*,mb:*,ex:*/,s0:/*,mb:\ ,ex:*/,:///,://!,://
    1              0.000001 else
    1              0.000013     setlocal comments=s0:/*!,ex:*/,s1:/*,mb:*,ex:*/,:///,://!,://
    1              0.000001 endif
    1              0.000007 setlocal commentstring=//%s
    1              0.000013 setlocal formatoptions-=t formatoptions+=croqnl
                            " j was only added in 7.3.541, so stop complaints about its nonexistence
    1              0.000062 silent! setlocal formatoptions+=j
                            
                            " smartindent will be overridden by indentexpr if filetype indent is on, but
                            " otherwise it's better than nothing.
    1              0.000018 setlocal smartindent nocindent
                            
    1              0.000009 if get(g:, 'rust_recommended_style', 1)
    1              0.000006     let b:rust_set_style = 1
    1              0.000014     setlocal shiftwidth=4 softtabstop=4 expandtab
    1              0.000007     setlocal textwidth=99
    1              0.000001 endif
                            
    1              0.000009 setlocal include=\\v^\\s*(pub\\s+)?use\\s+\\zs(\\f\|:)+
    1              0.000007 setlocal includeexpr=rust#IncludeExpr(v:fname)
                            
    1              0.000006 setlocal suffixesadd=.rs
                            
    1              0.000007 if exists("g:ftplugin_rust_source_path")
                                let &l:path=g:ftplugin_rust_source_path . ',' . &l:path
    1              0.000001 endif
                            
    1              0.000005 if exists("g:loaded_delimitMate")
                                if exists("b:delimitMate_excluded_regions")
                                    let b:rust_original_delimitMate_excluded_regions = b:delimitMate_excluded_regions
                                endif
                            
                                augroup rust.vim.DelimitMate
                                    autocmd!
                            
                                    autocmd User delimitMate_map   :call rust#delimitmate#onMap()
                                    autocmd User delimitMate_unmap :call rust#delimitmate#onUnmap()
                                augroup END
    1              0.000001 endif
                            
                            " Integration with auto-pairs (https://github.com/jiangmiao/auto-pairs)
    1              0.000008 if exists("g:AutoPairsLoaded") && !get(g:, 'rust_keep_autopairs_default', 0)
                                let b:AutoPairs = {'(':')', '[':']', '{':'}','"':'"', '`':'`'}
    1              0.000001 endif
                            
    1              0.000008 if has("folding") && get(g:, 'rust_fold', 0)
                                let b:rust_set_foldmethod=1
                                setlocal foldmethod=syntax
                                if g:rust_fold == 2
                                    setlocal foldlevel<
                                else
                                    setlocal foldlevel=99
                                endif
    1              0.000001 endif
                            
    1              0.000007 if has('conceal') && get(g:, 'rust_conceal', 0)
                                let b:rust_set_conceallevel=1
                                setlocal conceallevel=2
    1              0.000001 endif
                            
                            " Motion Commands {{{1
    1              0.000008 if !exists("g:no_plugin_maps") && !exists("g:no_rust_maps")
                                " Bind motion commands to support hanging indents
    1              0.000014     nnoremap <silent> <buffer> [[ :call rust#Jump('n', 'Back')<CR>
    1              0.000008     nnoremap <silent> <buffer> ]] :call rust#Jump('n', 'Forward')<CR>
    1              0.000008     xnoremap <silent> <buffer> [[ :call rust#Jump('v', 'Back')<CR>
    1              0.000007     xnoremap <silent> <buffer> ]] :call rust#Jump('v', 'Forward')<CR>
    1              0.000007     onoremap <silent> <buffer> [[ :call rust#Jump('o', 'Back')<CR>
    1              0.000006     onoremap <silent> <buffer> ]] :call rust#Jump('o', 'Forward')<CR>
    1              0.000001 endif
                            
                            " Commands {{{1
                            
                            " See |:RustRun| for docs
    1              0.000022 command! -nargs=* -complete=file -bang -buffer RustRun call rust#Run(<bang>0, <q-args>)
                            
                            " See |:RustExpand| for docs
    1              0.000013 command! -nargs=* -complete=customlist,rust#CompleteExpand -bang -buffer RustExpand call rust#Expand(<bang>0, <q-args>)
                            
                            " See |:RustEmitIr| for docs
    1              0.000006 command! -nargs=* -buffer RustEmitIr call rust#Emit("llvm-ir", <q-args>)
                            
                            " See |:RustEmitAsm| for docs
    1              0.000005 command! -nargs=* -buffer RustEmitAsm call rust#Emit("asm", <q-args>)
                            
                            " See |:RustPlay| for docs
    1              0.000021 command! -range=% -buffer RustPlay :call rust#Play(<count>, <line1>, <line2>, <f-args>)
                            
                            " See |:RustFmt| for docs
    1              0.000005 command! -bar -buffer RustFmt call rustfmt#Format()
                            
                            " See |:RustFmtRange| for docs
    1              0.000015 command! -range -buffer RustFmtRange call rustfmt#FormatRange(<line1>, <line2>)
                            
                            " See |:RustInfo| for docs
    1              0.000006 command! -bar -buffer RustInfo call rust#debugging#Info()
                            
                            " See |:RustInfoToClipboard| for docs
    1              0.000011 command! -bar -buffer RustInfoToClipboard call rust#debugging#InfoToClipboard()
                            
                            " See |:RustInfoToFile| for docs
    1              0.000007 command! -bar -nargs=1 -buffer RustInfoToFile call rust#debugging#InfoToFile(<f-args>)
                            
                            " See |:RustTest| for docs
    1              0.000016 command! -buffer -nargs=* -count -bang RustTest call rust#Test(<q-mods>, <count>, <bang>0, <q-args>)
                            
    1              0.000011 if !exists("b:rust_last_rustc_args") || !exists("b:rust_last_args")
    1              0.000006     let b:rust_last_rustc_args = []
    1              0.000004     let b:rust_last_args = []
    1              0.000001 endif
                            
                            " Cleanup {{{1
                            
    1              0.000063 let b:undo_ftplugin = "
                                        \ setlocal formatoptions< comments< commentstring< include< includeexpr< suffixesadd<
                                        \|if exists('b:rust_set_style')
                                            \|setlocal tabstop< shiftwidth< softtabstop< expandtab< textwidth<
                                            \|endif
                                            \|if exists('b:rust_original_delimitMate_excluded_regions')
                                                \|let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions
                                                \|unlet b:rust_original_delimitMate_excluded_regions
                                                \|else
                                                    \|unlet! b:delimitMate_excluded_regions
                                                    \|endif
                                                    \|if exists('b:rust_set_foldmethod')
                                                        \|setlocal foldmethod< foldlevel<
                                                        \|unlet b:rust_set_foldmethod
                                                        \|endif
                                                        \|if exists('b:rust_set_conceallevel')
                                                            \|setlocal conceallevel<
                                                            \|unlet b:rust_set_conceallevel
                                                            \|endif
                                                            \|unlet! b:rust_last_rustc_args b:rust_last_args
                                                            \|delcommand -buffer RustRun
                                                            \|delcommand -buffer RustExpand
                                                            \|delcommand -buffer RustEmitIr
                                                            \|delcommand -buffer RustEmitAsm
                                                            \|delcommand -buffer RustPlay
                                                            \|delcommand -buffer RustFmt
                                                            \|delcommand -buffer RustFmtRange
                                                            \|delcommand -buffer RustInfo
                                                            \|delcommand -buffer RustInfoToClipboard
                                                            \|delcommand -buffer RustInfoToFile
                                                            \|delcommand -buffer RustTest
                                                            \|silent! nunmap <buffer> [[
                                                            \|silent! nunmap <buffer> ]]
                                                            \|silent! xunmap <buffer> [[
                                                            \|silent! xunmap <buffer> ]]
                                                            \|silent! ounmap <buffer> [[
                                                            \|silent! ounmap <buffer> ]]
                                                            \|setlocal matchpairs-=<:>
                                                            \|unlet b:match_skip
                                                            \"
                            
                            " }}}1
                            
                            " Code formatting on save
    1              0.000003 augroup rust.vim.PreWrite
    1              0.000024     autocmd!
    1              0.000013     autocmd BufWritePre *.rs silent! call rustfmt#PreWrite()
    1              0.000002 augroup END
                            
    1              0.000013 setlocal matchpairs+=<:>
                            " For matchit.vim (rustArrow stops `Fn() -> X` messing things up)
    1              0.000006 let b:match_skip = 's:comment\|string\|rustCharacter\|rustArrow'
                            
    1              0.000006 command! -buffer -nargs=+ Cargo call cargo#cmd(<q-args>)
    1              0.000005 command! -buffer -nargs=* Cbuild call cargo#build(<q-args>)
    1              0.000004 command! -buffer -nargs=* Ccheck call cargo#check(<q-args>)
    1              0.000009 command! -buffer -nargs=* Cclean call cargo#clean(<q-args>)
    1              0.000005 command! -buffer -nargs=* Cdoc call cargo#doc(<q-args>)
    1              0.000004 command! -buffer -nargs=+ Cnew call cargo#new(<q-args>)
    1              0.000004 command! -buffer -nargs=* Cinit call cargo#init(<q-args>)
    1              0.000006 command! -buffer -nargs=* Crun call cargo#run(<q-args>)
    1              0.000005 command! -buffer -nargs=* Ctest call cargo#test(<q-args>)
    1              0.000009 command! -buffer -nargs=* Cbench call cargo#bench(<q-args>)
    1              0.000005 command! -buffer -nargs=* Cupdate call cargo#update(<q-args>)
    1              0.000005 command! -buffer -nargs=* Csearch  call cargo#search(<q-args>)
    1              0.000005 command! -buffer -nargs=* Cpublish call cargo#publish(<q-args>)
    1              0.000005 command! -buffer -nargs=* Cinstall call cargo#install(<q-args>)
    1              0.000005 command! -buffer -nargs=* Cruntarget call cargo#runtarget(<q-args>)
                            
    1              0.000026 let b:undo_ftplugin .= '
                                        \|delcommand -buffer Cargo
                                        \|delcommand -buffer Cbuild
                                        \|delcommand -buffer Ccheck
                                        \|delcommand -buffer Cclean
                                        \|delcommand -buffer Cdoc
                                        \|delcommand -buffer Cnew
                                        \|delcommand -buffer Cinit
                                        \|delcommand -buffer Crun
                                        \|delcommand -buffer Ctest
                                        \|delcommand -buffer Cbench
                                        \|delcommand -buffer Cupdate
                                        \|delcommand -buffer Csearch
                                        \|delcommand -buffer Cpublish
                                        \|delcommand -buffer Cinstall
                                        \|delcommand -buffer Cruntarget'
                            
                            " vint: -ProhibitAbbreviationOption
    1              0.000014 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            " vint: +ProhibitAbbreviationOption
                            
                            " vim: set et sw=4 sts=4 ts=8:

SCRIPT  /usr/share/nvim/runtime/compiler/cargo.vim
Sourced 1 time
Total time:   0.001144
 Self time:   0.000889

count  total (s)   self (s)
                            " Vim compiler file
                            " Compiler:         Cargo Compiler
                            " Maintainer:       Damien Radtke <damienradtke@gmail.com>
                            " Latest Revision:  2023-09-11
                            "                   2024 Apr 05 by The Vim Project (removed :CompilerSet definition)
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
    1              0.000017 if exists('current_compiler')
                                finish
    1              0.000002 endif
    1   0.000900   0.000646 runtime compiler/rustc.vim
    1              0.000010 let current_compiler = "cargo"
                            
                            " vint: -ProhibitAbbreviationOption
    1              0.000009 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            " vint: +ProhibitAbbreviationOption
                            
    1              0.000007 if exists('g:cargo_makeprg_params')
                                execute 'CompilerSet makeprg=cargo\ '.escape(g:cargo_makeprg_params, ' \|"').'\ $*'
    1              0.000002 else
    1              0.000015     CompilerSet makeprg=cargo\ $*
    1              0.000002 endif
                            
    1              0.000005 augroup RustCargoQuickFixHooks
    1              0.000038     autocmd!
    1              0.000017     autocmd QuickFixCmdPre make call cargo#quickfix#CmdPre()
    1              0.000008     autocmd QuickFixCmdPost make call cargo#quickfix#CmdPost()
    1              0.000002 augroup END
                            
                            " Ignore general cargo progress messages
    1              0.000037 CompilerSet errorformat+=
                                        \%-G%\\s%#Downloading%.%#,
                                        \%-G%\\s%#Checking%.%#,
                                        \%-G%\\s%#Compiling%.%#,
                                        \%-G%\\s%#Finished%.%#,
                                        \%-G%\\s%#error:\ Could\ not\ compile\ %.%#,
                                        \%-G%\\s%#To\ learn\ more\\,%.%#,
                                        \%-G%\\s%#For\ more\ information\ about\ this\ error\\,%.%#,
                                        \%-Gnote:\ Run\ with\ \`RUST_BACKTRACE=%.%#,
                                        \%.%#panicked\ at\ \\'%m\\'\\,\ %f:%l:%c
                            
                            " vint: -ProhibitAbbreviationOption
    1              0.000012 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            " vint: +ProhibitAbbreviationOption
                            
                            " vim: set et sw=4 sts=4 ts=8:

SCRIPT  /usr/share/nvim/runtime/compiler/rustc.vim
Sourced 1 time
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
                            " Vim compiler file
                            " Compiler:         Rust Compiler
                            " Maintainer:       Chris Morgan <me@chrismorgan.info>
                            " Latest Revision:  2023-09-11
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
    1              0.000008 if exists("current_compiler")
                                finish
    1              0.000001 endif
    1              0.000013 let current_compiler = "rustc"
                            
                            " vint: -ProhibitAbbreviationOption
    1              0.000012 let s:save_cpo = &cpo
    1              0.000017 set cpo&vim
                            " vint: +ProhibitAbbreviationOption
                            
    1              0.000008 if get(g:, 'rustc_makeprg_no_percent', 0)
                                CompilerSet makeprg=rustc
    1              0.000002 else
    1              0.000009     if has('patch-7.4.191')
    1              0.000018       CompilerSet makeprg=rustc\ \%:S
                                else
                                  CompilerSet makeprg=rustc\ \"%\"
    1              0.000002     endif
    1              0.000001 endif
                            
                            " New errorformat (after nightly 2016/08/10)
    1              0.000030 CompilerSet errorformat=
                                        \%-G,
                                        \%-Gerror:\ aborting\ %.%#,
                                        \%-Gerror:\ Could\ not\ compile\ %.%#,
                                        \%Eerror:\ %m,
                                        \%Eerror[E%n]:\ %m,
                                        \%Wwarning:\ %m,
                                        \%Inote:\ %m,
                                        \%C\ %#-->\ %f:%l:%c,
                                        \%E\ \ left:%m,%C\ right:%m\ %f:%l:%c,%Z
                            
                            " Old errorformat (before nightly 2016/08/10)
    1              0.000050 CompilerSet errorformat+=
                                        \%f:%l:%c:\ %t%*[^:]:\ %m,
                                        \%f:%l:%c:\ %*\\d:%*\\d\ %t%*[^:]:\ %m,
                                        \%-G%f:%l\ %s,
                                        \%-G%*[\ ]^,
                                        \%-G%*[\ ]^%*[~],
                                        \%-G%*[\ ]...
                            
                            " vint: -ProhibitAbbreviationOption
    1              0.000016 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            " vint: +ProhibitAbbreviationOption
                            
                            " vim: set et sw=4 sts=4 ts=8:

SCRIPT  /usr/share/nvim/runtime/indent/rust.vim
Sourced 1 time
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
                            " Vim indent file
                            " Language:         Rust
                            " Author:           Chris Morgan <me@chrismorgan.info>
                            " Last Change:      2023-09-11
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
                            " Only load this indent file when no other was loaded.
    1              0.000009 if exists("b:did_indent")
                                finish
    1              0.000001 endif
    1              0.000004 let b:did_indent = 1
                            
    1              0.000008 setlocal cindent
    1              0.000009 setlocal cinoptions=L0,(s,Ws,J1,j1,m1
    1              0.000006 setlocal cinkeys=0{,0},!^F,o,O,0[,0],0(,0)
                            " Don't think cinwords will actually do anything at all... never mind
    1              0.000006 setlocal cinwords=for,if,else,while,loop,impl,mod,unsafe,trait,struct,enum,fn,extern,macro
                            
                            " Some preliminary settings
    1              0.000019 setlocal nolisp		" Make sure lisp indenting doesn't supersede us
    1              0.000004 setlocal autoindent	" indentexpr isn't much help otherwise
                            " Also do indentkeys, otherwise # gets shoved to column 0 :-/
    1              0.000005 setlocal indentkeys=0{,0},!^F,o,O,0[,0],0(,0)
                            
    1              0.000005 setlocal indentexpr=GetRustIndent(v:lnum)
                            
    1              0.000006 let b:undo_indent = "setlocal cindent< cinoptions< cinkeys< cinwords< lisp< autoindent< indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000005 if exists("*GetRustIndent")
    1              0.000002     finish
                            endif
                            
                            " vint: -ProhibitAbbreviationOption
                            let s:save_cpo = &cpo
                            set cpo&vim
                            " vint: +ProhibitAbbreviationOption
                            
                            " Come here when loading the script the first time.
                            
                            function! s:get_line_trimmed(lnum)
                                " Get the line and remove a trailing comment.
                                " Use syntax highlighting attributes when possible.
                                " NOTE: this is not accurate; /* */ or a line continuation could trick it
                                let line = getline(a:lnum)
                                let line_len = strlen(line)
                                if has('syntax_items')
                                    " If the last character in the line is a comment, do a binary search for
                                    " the start of the comment.  synID() is slow, a linear search would take
                                    " too long on a long line.
                                    if synIDattr(synID(a:lnum, line_len, 1), "name") =~? 'Comment\|Todo'
                                        let min = 1
                                        let max = line_len
                                        while min < max
                                            let col = (min + max) / 2
                                            if synIDattr(synID(a:lnum, col, 1), "name") =~? 'Comment\|Todo'
                                                let max = col
                                            else
                                                let min = col + 1
                                            endif
                                        endwhile
                                        let line = strpart(line, 0, min - 1)
                                    endif
                                    return substitute(line, "\s*$", "", "")
                                else
                                    " Sorry, this is not complete, nor fully correct (e.g. string "//").
                                    " Such is life.
                                    return substitute(line, "\s*//.*$", "", "")
                                endif
                            endfunction
                            
                            function! s:is_string_comment(lnum, col)
                                if has('syntax_items')
                                    for id in synstack(a:lnum, a:col)
                                        let synname = synIDattr(id, "name")
                                        if synname ==# "rustString" || synname =~# "^rustComment"
                                            return 1
                                        endif
                                    endfor
                                else
                                    " without syntax, let's not even try
                                    return 0
                                endif
                            endfunction
                            
                            if exists('*shiftwidth')
                                function! s:shiftwidth()
                                    return shiftwidth()
                                endfunc
                            else
                                function! s:shiftwidth()
                                    return &shiftwidth
                                endfunc
                            endif
                            
                            function GetRustIndent(lnum)
                                " Starting assumption: cindent (called at the end) will do it right
                                " normally. We just want to fix up a few cases.
                            
                                let line = getline(a:lnum)
                            
                                if has('syntax_items')
                                    let synname = synIDattr(synID(a:lnum, 1, 1), "name")
                                    if synname ==# "rustString"
                                        " If the start of the line is in a string, don't change the indent
                                        return -1
                                    elseif synname =~? '\(Comment\|Todo\)'
                                                \ && line !~# '^\s*/\*'  " not /* opening line
                                        if synname =~? "CommentML" " multi-line
                                            if line !~# '^\s*\*' && getline(a:lnum - 1) =~# '^\s*/\*'
                                                " This is (hopefully) the line after a /*, and it has no
                                                " leader, so the correct indentation is that of the
                                                " previous line.
                                                return GetRustIndent(a:lnum - 1)
                                            endif
                                        endif
                                        " If it's in a comment, let cindent take care of it now. This is
                                        " for cases like "/*" where the next line should start " * ", not
                                        " "* " as the code below would otherwise cause for module scope
                                        " Fun fact: "  /*\n*\n*/" takes two calls to get right!
                                        return cindent(a:lnum)
                                    endif
                                endif
                            
                                " cindent gets second and subsequent match patterns/struct members wrong,
                                " as it treats the comma as indicating an unfinished statement::
                                "
                                " match a {
                                "     b => c,
                                "         d => e,
                                "         f => g,
                                " };
                            
                                " Search backwards for the previous non-empty line.
                                let prevlinenum = prevnonblank(a:lnum - 1)
                                let prevline = s:get_line_trimmed(prevlinenum)
                                while prevlinenum > 1 && prevline !~# '[^[:blank:]]'
                                    let prevlinenum = prevnonblank(prevlinenum - 1)
                                    let prevline = s:get_line_trimmed(prevlinenum)
                                endwhile
                            
                                " A standalone '{', '}', or 'where'
                                let l:standalone_open = line =~# '\V\^\s\*{\s\*\$'
                                let l:standalone_close = line =~# '\V\^\s\*}\s\*\$'
                                let l:standalone_where = line =~# '\V\^\s\*where\s\*\$'
                                if l:standalone_open || l:standalone_close || l:standalone_where
                                    " ToDo: we can search for more items than 'fn' and 'if'.
                                    let [l:found_line, l:col, l:submatch] =
                                                \ searchpos('\<\(fn\)\|\(if\)\>', 'bnWp')
                                    if l:found_line !=# 0
                                        " Now we count the number of '{' and '}' in between the match
                                        " locations and the current line (there is probably a better
                                        " way to compute this).
                                        let l:i = l:found_line
                                        let l:search_line = strpart(getline(l:i), l:col - 1)
                                        let l:opens = 0
                                        let l:closes = 0
                                        while l:i < a:lnum
                                            let l:search_line2 = substitute(l:search_line, '\V{', '', 'g')
                                            let l:opens += strlen(l:search_line) - strlen(l:search_line2)
                                            let l:search_line3 = substitute(l:search_line2, '\V}', '', 'g')
                                            let l:closes += strlen(l:search_line2) - strlen(l:search_line3)
                                            let l:i += 1
                                            let l:search_line = getline(l:i)
                                        endwhile
                                        if l:standalone_open || l:standalone_where
                                            if l:opens ==# l:closes
                                                return indent(l:found_line)
                                            endif
                                        else
                                            " Expect to find just one more close than an open
                                            if l:opens ==# l:closes + 1
                                                return indent(l:found_line)
                                            endif
                                        endif
                                    endif
                                endif
                            
                                " A standalone 'where' adds a shift.
                                let l:standalone_prevline_where = prevline =~# '\V\^\s\*where\s\*\$'
                                if l:standalone_prevline_where
                                    return indent(prevlinenum) + 4
                                endif
                            
                                " Handle where clauses nicely: subsequent values should line up nicely.
                                if prevline[len(prevline) - 1] ==# ","
                                            \ && prevline =~# '^\s*where\s'
                                    return indent(prevlinenum) + 6
                                endif
                            
                                let l:last_prevline_character = prevline[len(prevline) - 1]
                            
                                " A line that ends with '.<expr>;' is probably an end of a long list
                                " of method operations.
                                if prevline =~# '\V\^\s\*.' && l:last_prevline_character ==# ';'
                                    call cursor(a:lnum - 1, 1)
                                    let l:scope_start = searchpair('{\|(', '', '}\|)', 'nbW',
                                                \ 's:is_string_comment(line("."), col("."))')
                                    if l:scope_start != 0 && l:scope_start < a:lnum
                                        return indent(l:scope_start) + 4
                                    endif
                                endif
                            
                                if l:last_prevline_character ==# ","
                                            \ && s:get_line_trimmed(a:lnum) !~# '^\s*[\[\]{})]'
                                            \ && prevline !~# '^\s*fn\s'
                                            \ && prevline !~# '([^()]\+,$'
                                            \ && s:get_line_trimmed(a:lnum) !~# '^\s*\S\+\s*=>'
                                    " Oh ho! The previous line ended in a comma! I bet cindent will try to
                                    " take this too far... For now, let's normally use the previous line's
                                    " indent.
                            
                                    " One case where this doesn't work out is where *this* line contains
                                    " square or curly brackets; then we normally *do* want to be indenting
                                    " further.
                                    "
                                    " Another case where we don't want to is one like a function
                                    " definition with arguments spread over multiple lines:
                                    "
                                    " fn foo(baz: Baz,
                                    "        baz: Baz) // <-- cindent gets this right by itself
                                    "
                                    " Another case is similar to the previous, except calling a function
                                    " instead of defining it, or any conditional expression that leaves
                                    " an open paren:
                                    "
                                    " foo(baz,
                                    "     baz);
                                    "
                                    " if baz && (foo ||
                                    "            bar) {
                                    "
                                    " Another case is when the current line is a new match arm.
                                    "
                                    " There are probably other cases where we don't want to do this as
                                    " well. Add them as needed.
                                    return indent(prevlinenum)
                                endif
                            
                                if !has("patch-7.4.355")
                                    " cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
                                    "
                                    " static FOO : &'static [bool] = [
                                    " true,
                                    "	 false,
                                    "	 false,
                                    "	 true,
                                    "	 ];
                                    "
                                    "	 uh oh, next statement is indented further!
                            
                                    " Note that this does *not* apply the line continuation pattern properly;
                                    " that's too hard to do correctly for my liking at present, so I'll just
                                    " start with these two main cases (square brackets and not returning to
                                    " column zero)
                            
                                    call cursor(a:lnum, 1)
                                    if searchpair('{\|(', '', '}\|)', 'nbW',
                                                \ 's:is_string_comment(line("."), col("."))') == 0
                                        if searchpair('\[', '', '\]', 'nbW',
                                                    \ 's:is_string_comment(line("."), col("."))') == 0
                                            " Global scope, should be zero
                                            return 0
                                        else
                                            " At the module scope, inside square brackets only
                                            "if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
                                            if line =~# "^\\s*]"
                                                " It's the closing line, dedent it
                                                return 0
                                            else
                                                return &shiftwidth
                                            endif
                                        endif
                                    endif
                                endif
                            
                                " Fall back on cindent, which does it mostly right
                                return cindent(a:lnum)
                            endfunction
                            
                            " vint: -ProhibitAbbreviationOption
                            let &cpo = s:save_cpo
                            unlet s:save_cpo
                            " vint: +ProhibitAbbreviationOption
                            
                            " vim: set et sw=4 sts=4 ts=8:

SCRIPT  /usr/share/nvim/runtime/syntax/rust.vim
Sourced 2 times
Total time: 5054.006995
 Self time: 5054.001788

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Rust
                            " Maintainer:   Patrick Walton <pcwalton@mozilla.com>
                            " Maintainer:   Ben Blum <bblum@cs.cmu.edu>
                            " Maintainer:   Chris Morgan <me@chrismorgan.info>
                            " Last Change:  2023-09-11
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
    2              0.000006 if version < 600
                                syntax clear
    2              0.000006 elseif exists("b:current_syntax")
                                finish
    2              0.000001 endif
                            
                            " Syntax definitions {{{1
                            " Basic keywords {{{2
    2              0.000006 syn keyword   rustConditional match if else
    2              0.000003 syn keyword   rustRepeat loop while
                            " `:syn match` must be used to prioritize highlighting `for` keyword.
    2              0.000011 syn match     rustRepeat /\<for\>/
                            " Highlight `for` keyword in `impl ... for ... {}` statement. This line must
                            " be put after previous `syn match` line to overwrite it.
    2              0.000013 syn match     rustKeyword /\%(\<impl\>.\+\)\@<=\<for\>/
    2              0.000002 syn keyword   rustRepeat in
    2              0.000005 syn keyword   rustTypedef type nextgroup=rustIdentifier skipwhite skipempty
    2              0.000004 syn keyword   rustStructure struct enum nextgroup=rustIdentifier skipwhite skipempty
    2              0.000003 syn keyword   rustUnion union nextgroup=rustIdentifier skipwhite skipempty contained
    2              0.000017 syn match rustUnionContextual /\<union\_s\+\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*/ transparent contains=rustUnion
    2              0.000002 syn keyword   rustOperator    as
    2              0.000004 syn keyword   rustExistential existential nextgroup=rustTypedef skipwhite skipempty contained
    2              0.000010 syn match rustExistentialContextual /\<existential\_s\+type/ transparent contains=rustExistential,rustTypedef
                            
    2              0.000008 syn match     rustAssert      "\<assert\(\w\)*!" contained
    2              0.000006 syn match     rustPanic       "\<panic\(\w\)*!" contained
    2              0.000008 syn match     rustAsync       "\<async\%(\s\|\n\)\@="
    2              0.000003 syn keyword   rustKeyword     break
    2              0.000002 syn keyword   rustKeyword     box
    2              0.000002 syn keyword   rustKeyword     continue
    2              0.000002 syn keyword   rustKeyword     crate
    2              0.000007 syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite skipempty
    2              0.000003 syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite skipempty
    2              0.000002 syn keyword   rustKeyword     impl let
    2              0.000002 syn keyword   rustKeyword     macro
    2              0.000004 syn keyword   rustKeyword     pub nextgroup=rustPubScope skipwhite skipempty
    2              0.000002 syn keyword   rustKeyword     return
    2              0.000002 syn keyword   rustKeyword     yield
    2              0.000002 syn keyword   rustSuper       super
    2              0.000002 syn keyword   rustKeyword     where
    2              0.000002 syn keyword   rustUnsafeKeyword unsafe
    2              0.000003 syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite skipempty
                            " FIXME: Scoped impl's name is also fallen in this category
    2              0.000003 syn keyword   rustKeyword     mod trait nextgroup=rustIdentifier skipwhite skipempty
    2              0.000003 syn keyword   rustStorage     move mut ref static const
    2              0.000011 syn match     rustDefault     /\<default\ze\_s\+\(impl\|fn\|type\|const\)\>/
    2              0.000002 syn keyword   rustAwait       await
    2              0.000007 syn match     rustKeyword     /\<try\>!\@!/ display
                            
    2              0.000002 syn keyword rustPubScopeCrate crate contained
    2              0.000006 syn match rustPubScopeDelim /[()]/ contained
    2              0.000010 syn match rustPubScope /([^()]*)/ contained contains=rustPubScopeDelim,rustPubScopeCrate,rustSuper,rustModPath,rustModPathSep,rustSelf transparent
                            
    2              0.000005 syn keyword   rustExternCrate crate contained nextgroup=rustIdentifier,rustExternCrateString skipwhite skipempty
                            " This is to get the `bar` part of `extern crate "foo" as bar;` highlighting.
    2              0.000007 syn match   rustExternCrateString /".*"\_s*as/ contained nextgroup=rustIdentifier skipwhite transparent skipempty contains=rustString,rustOperator
    2              0.000003 syn keyword   rustObsoleteExternMod mod contained nextgroup=rustIdentifier skipwhite skipempty
                            
    2              0.000013 syn match     rustIdentifier  contains=rustIdentifierPrime "\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
    2              0.000011 syn match     rustFuncName    "\%(r#\)\=\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
                            
    2              0.000013 syn region rustMacroRepeat matchgroup=rustMacroRepeatDelimiters start="$(" end="),\=[*+]" contains=TOP
    2              0.000007 syn match rustMacroVariable "$\w\+"
    2              0.000006 syn match rustRawIdent "\<r#\h\w*" contains=NONE
                            
                            " Reserved (but not yet used) keywords {{{2
    2              0.000006 syn keyword   rustReservedKeyword become do priv typeof unsized abstract virtual final override
                            
                            " Built-in types {{{2
    2              0.000005 syn keyword   rustType        isize usize char bool u8 u16 u32 u64 u128 f32
    2              0.000004 syn keyword   rustType        f64 i8 i16 i32 i64 i128 str Self
                            
                            " Things from the libstd v1 prelude (src/libstd/prelude/v1.rs) {{{2
                            " This section is just straight transformation of the contents of the prelude,
                            " to make it easy to update.
                            
                            " Reexported core operators {{{3
    2              0.000004 syn keyword   rustTrait       Copy Send Sized Sync
    2              0.000003 syn keyword   rustTrait       Drop Fn FnMut FnOnce
                            
                            " Reexported functions {{{3
                            " There’s no point in highlighting these; when one writes drop( or drop::< it
                            " gets the same highlighting anyway, and if someone writes `let drop = …;` we
                            " don’t really want *that* drop to be highlighted.
                            "syn keyword rustFunction drop
                            
                            " Reexported types and traits {{{3
    2              0.000002 syn keyword rustTrait Box
    2              0.000002 syn keyword rustTrait ToOwned
    2              0.000002 syn keyword rustTrait Clone
    2              0.000003 syn keyword rustTrait PartialEq PartialOrd Eq Ord
    2              0.000003 syn keyword rustTrait AsRef AsMut Into From
    2              0.000002 syn keyword rustTrait Default
    2              0.000003 syn keyword rustTrait Iterator Extend IntoIterator
    2              0.000003 syn keyword rustTrait DoubleEndedIterator ExactSizeIterator
    2              0.000002 syn keyword rustEnum Option
    2              0.000003 syn keyword rustEnumVariant Some None
    2              0.000002 syn keyword rustEnum Result
    2              0.000003 syn keyword rustEnumVariant Ok Err
    2              0.000002 syn keyword rustTrait SliceConcatExt
    2              0.000002 syn keyword rustTrait String ToString
    2              0.000002 syn keyword rustTrait Vec
                            
                            " Other syntax {{{2
    2              0.000002 syn keyword   rustSelf        self
    2              0.000003 syn keyword   rustBoolean     true false
                            
                            " If foo::bar changes to foo.bar, change this ("::" to "\.").
                            " If foo::bar changes to Foo::bar, change this (first "\w" to "\u").
    2              0.000007 syn match     rustModPath     "\w\(\w\)*::[^<]"he=e-3,me=e-3
    2              0.000004 syn match     rustModPathSep  "::"
                            
    2              0.000007 syn match     rustFuncCall    "\w\(\w\)*("he=e-1,me=e-1
    2              0.000007 syn match     rustFuncCall    "\w\(\w\)*::<"he=e-3,me=e-3 " foo::<T>();
                            
                            " This is merely a convention; note also the use of [A-Z], restricting it to
                            " latin identifiers rather than the full Unicode uppercase. I have not used
                            " [:upper:] as it depends upon 'noignorecase'
                            "syn match     rustCapsIdent    display "[A-Z]\w\(\w\)*"
                            
    2              0.000010 syn match     rustOperator     display "\%(+\|-\|/\|*\|=\|\^\|&\||\|!\|>\|<\|%\)=\?"
                            " This one isn't *quite* right, as we could have binary-& with a reference
    2              0.000011 syn match     rustSigil        display /&\s\+[&~@*][^)= \t\r\n]/he=e-1,me=e-1
    2              0.000010 syn match     rustSigil        display /[&~@*][^)= \t\r\n]/he=e-1,me=e-1
                            " This isn't actually correct; a closure with no arguments can be `|| { }`.
                            " Last, because the & in && isn't a sigil
    2              0.000006 syn match     rustOperator     display "&&\|||"
                            " This is rustArrowCharacter rather than rustArrow for the sake of matchparen,
                            " so it skips the ->; see http://stackoverflow.com/a/30309949 for details.
    2              0.000004 syn match     rustArrowCharacter display "->"
    2              0.000006 syn match     rustQuestionMark display "?\([a-zA-Z]\+\)\@!"
                            
    2              0.000008 syn match     rustMacro       '\w\(\w\)*!' contains=rustAssert,rustPanic
    2              0.000007 syn match     rustMacro       '#\w\(\w\)*' contains=rustAssert,rustPanic
                            
    2              0.000005 syn match     rustEscapeError   display contained /\\./
    2              0.000009 syn match     rustEscape        display contained /\\\([nrt0\\'"]\|x\x\{2}\)/
    2              0.000009 syn match     rustEscapeUnicode display contained /\\u{\%(\x_*\)\{1,6}}/
    2              0.000006 syn match     rustStringContinuation display contained /\\\n\s*/
    2              0.000025 syn region    rustString      matchgroup=rustStringDelimiter start=+b"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeError,rustStringContinuation
    2              0.000017 syn region    rustString      matchgroup=rustStringDelimiter start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustStringContinuation,@Spell
    2              0.000012 syn region    rustString      matchgroup=rustStringDelimiter start='b\?r\z(#*\)"' end='"\z1' contains=@Spell
                            
                            " Match attributes with either arbitrary syntax or special highlighting for
                            " derives. We still highlight strings and comments inside of the attribute.
    2              0.000019 syn region    rustAttribute   start="#!\?\[" end="\]" contains=@rustAttributeContents,rustAttributeParenthesizedParens,rustAttributeParenthesizedCurly,rustAttributeParenthesizedBrackets,rustDerive
    2              0.000012 syn region    rustAttributeParenthesizedParens matchgroup=rustAttribute start="\w\%(\w\)*("rs=e end=")"re=s transparent contained contains=rustAttributeBalancedParens,@rustAttributeContents
    2              0.000009 syn region    rustAttributeParenthesizedCurly matchgroup=rustAttribute start="\w\%(\w\)*{"rs=e end="}"re=s transparent contained contains=rustAttributeBalancedCurly,@rustAttributeContents
    2              0.000008 syn region    rustAttributeParenthesizedBrackets matchgroup=rustAttribute start="\w\%(\w\)*\["rs=e end="\]"re=s transparent contained contains=rustAttributeBalancedBrackets,@rustAttributeContents
    2              0.000007 syn region    rustAttributeBalancedParens matchgroup=rustAttribute start="("rs=e end=")"re=s transparent contained contains=rustAttributeBalancedParens,@rustAttributeContents
    2              0.000007 syn region    rustAttributeBalancedCurly matchgroup=rustAttribute start="{"rs=e end="}"re=s transparent contained contains=rustAttributeBalancedCurly,@rustAttributeContents
    2              0.000007 syn region    rustAttributeBalancedBrackets matchgroup=rustAttribute start="\["rs=e end="\]"re=s transparent contained contains=rustAttributeBalancedBrackets,@rustAttributeContents
    2              0.000007 syn cluster   rustAttributeContents contains=rustString,rustCommentLine,rustCommentBlock,rustCommentLineDocError,rustCommentBlockDocError
    2              0.000009 syn region    rustDerive      start="derive(" end=")" contained contains=rustDeriveTrait
                            " This list comes from src/libsyntax/ext/deriving/mod.rs
                            " Some are deprecated (Encodable, Decodable) or to be removed after a new snapshot (Show).
    2              0.000009 syn keyword   rustDeriveTrait contained Clone Hash RustcEncodable RustcDecodable Encodable Decodable PartialEq Eq PartialOrd Ord Rand Show Debug Default FromPrimitive Send Sync Copy
                            
                            " dyn keyword: It's only a keyword when used inside a type expression, so
                            " we make effort here to highlight it only when Rust identifiers follow it
                            " (not minding the case of pre-2018 Rust where a path starting with :: can
                            " follow).
                            "
                            " This is so that uses of dyn variable names such as in 'let &dyn = &2'
                            " and 'let dyn = 2' will not get highlighted as a keyword.
    2              0.000012 syn match     rustKeyword "\<dyn\ze\_s\+\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)" contains=rustDynKeyword
    2              0.000002 syn keyword   rustDynKeyword  dyn contained
                            
                            " Number literals
    2              0.000013 syn match     rustDecNumber   display "\<[0-9][0-9_]*\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    2              0.000012 syn match     rustHexNumber   display "\<0x[a-fA-F0-9_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    2              0.000010 syn match     rustOctNumber   display "\<0o[0-7_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    2              0.000008 syn match     rustBinNumber   display "\<0b[01_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
                            
                            " Special case for numbers of the form "1." which are float literals, unless followed by
                            " an identifier, which makes them integer literals with a method call or field access,
                            " or by another ".", which makes them integer literals followed by the ".." token.
                            " (This must go first so the others take precedence.)
    2              0.000009 syn match     rustFloat       display "\<[0-9][0-9_]*\.\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\|\.\)\@!"
                            " To mark a number as a normal float, it must have at least one of the three things integral values don't have:
                            " a decimal point and more numbers; an exponent; and a type suffix.
    2              0.000014 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)\="
    2              0.000011 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\(f32\|f64\)\="
    2              0.000013 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)"
                            
                            " For the benefit of delimitMate
    2              0.000026 syn region rustLifetimeCandidate display start=/&'\%(\([^'\\]\|\\\(['nrt0\\\"]\|x\x\{2}\|u{\%(\x_*\)\{1,6}}\)\)'\)\@!/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
    2              0.000013 syn region rustGenericRegion display start=/<\%('\|[^[:cntrl:][:space:][:punct:]]\)\@=')\S\@=/ end=/>/ contains=rustGenericLifetimeCandidate
    2              0.000018 syn region rustGenericLifetimeCandidate display start=/\%(<\|,\s*\)\@<='/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
                            
                            "rustLifetime must appear before rustCharacter, or chars will get the lifetime highlighting
    2              0.000013 syn match     rustLifetime    display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*"
    2              0.000008 syn match     rustLabel       display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*:"
    2              0.000015 syn match     rustLabel       display "\%(\<\%(break\|continue\)\s*\)\@<=\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*"
    2              0.000007 syn match   rustCharacterInvalid   display contained /b\?'\zs[\n\r\t']\ze'/
                            " The groups negated here add up to 0-255 but nothing else (they do not seem to go beyond ASCII).
    2              0.000007 syn match   rustCharacterInvalidUnicode   display contained /b'\zs[^[:cntrl:][:graph:][:alnum:][:space:]]\ze'/
    2              0.000014 syn match   rustCharacter   /b'\([^\\]\|\\\(.\|x\x\{2}\)\)'/ contains=rustEscape,rustEscapeError,rustCharacterInvalid,rustCharacterInvalidUnicode
    2              0.000014 syn match   rustCharacter   /'\([^\\]\|\\\(.\|x\x\{2}\|u{\%(\x_*\)\{1,6}}\)\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid
                            
    2              0.000007 syn match rustShebang /\%^#![^[].*/
    2              0.000010 syn region rustCommentLine                                                  start="//"                      end="$"   contains=rustTodo,@Spell
    2              0.000011 syn region rustCommentLineDoc                                               start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell
    2              0.000008 syn region rustCommentLineDocError                                          start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell contained
    2              0.000012 syn region rustCommentBlock             matchgroup=rustCommentBlock         start="/\*\%(!\|\*[*/]\@!\)\@!" end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell
    2              0.000013 syn region rustCommentBlockDoc          matchgroup=rustCommentBlockDoc      start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNest,rustCommentBlockDocRustCode,@Spell
    2              0.000010 syn region rustCommentBlockDocError     matchgroup=rustCommentBlockDocError start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained
    2              0.000008 syn region rustCommentBlockNest         matchgroup=rustCommentBlock         start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell contained transparent
    2              0.000007 syn region rustCommentBlockDocNest      matchgroup=rustCommentBlockDoc      start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNest,@Spell contained transparent
    2              0.000008 syn region rustCommentBlockDocNestError matchgroup=rustCommentBlockDocError start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained transparent
                            
                            " FIXME: this is a really ugly and not fully correct implementation. Most
                            " importantly, a case like ``/* */*`` should have the final ``*`` not being in
                            " a comment, but in practice at present it leaves comments open two levels
                            " deep. But as long as you stay away from that particular case, I *believe*
                            " the highlighting is correct. Due to the way Vim's syntax engine works
                            " (greedy for start matches, unlike Rust's tokeniser which is searching for
                            " the earliest-starting match, start or end), I believe this cannot be solved.
                            " Oh you who would fix it, don't bother with things like duplicating the Block
                            " rules and putting ``\*\@<!`` at the start of them; it makes it worse, as
                            " then you must deal with cases like ``/*/**/*/``. And don't try making it
                            " worse with ``\%(/\@<!\*\)\@<!``, either...
                            
    2              0.000005 syn keyword rustTodo contained TODO FIXME XXX NB NOTE SAFETY
                            
                            " asm! macro {{{2
    2              0.002962 syn region rustAsmMacro matchgroup=rustMacro start="\<asm!\s*(" end=")" contains=rustAsmDirSpec,rustAsmSym,rustAsmConst,rustAsmOptionsGroup,rustComment.*,rustString.*
                            
                            " Clobbered registers
    2              0.000011 syn keyword rustAsmDirSpec in out lateout inout inlateout contained nextgroup=rustAsmReg skipwhite skipempty
    2              0.000010 syn region  rustAsmReg start="(" end=")" contained contains=rustString
                            
                            " Symbol operands
    2              0.000004 syn keyword rustAsmSym sym contained nextgroup=rustAsmSymPath skipwhite skipempty
    2              0.001462 syn region  rustAsmSymPath start="\S" end=",\|)"me=s-1 contained contains=rustComment.*,rustIdentifier
                            
                            " Const
    2              0.000029 syn region  rustAsmConstBalancedParens start="("ms=s+1 end=")" contained contains=@rustAsmConstExpr
    2              0.004356 syn cluster rustAsmConstExpr contains=rustComment.*,rust.*Number,rustString,rustAsmConstBalancedParens
    2              0.000058 syn region  rustAsmConst start="const" end=",\|)"me=s-1 contained contains=rustStorage,@rustAsmConstExpr
                            
                            " Options
    2              0.000022 syn region  rustAsmOptionsGroup start="options\s*(" end=")" contained contains=rustAsmOptions,rustAsmOptionsKey
    2              0.000006 syn keyword rustAsmOptionsKey options contained
    2              0.000009 syn keyword rustAsmOptions pure nomem readonly preserves_flags noreturn nostack att_syntax contained
                            
                            " Folding rules {{{2
                            " Trivial folding rules to begin with.
                            " FIXME: use the AST to make really good folding
    2              0.000017 syn region rustFoldBraces start="{" end="}" transparent fold
                            
    2              0.000023 if !exists("b:current_syntax_embed")
    1              0.000004     let b:current_syntax_embed = 1
    1              0.000054     syntax include @RustCodeInComment <sfile>:p:h/rust.vim
    1              0.000004     unlet b:current_syntax_embed
                            
                                " Currently regions marked as ```<some-other-syntax> will not get
                                " highlighted at all. In the future, we can do as vim-markdown does and
                                " highlight with the other syntax. But for now, let's make sure we find
                                " the closing block marker, because the rules below won't catch it.
    1              0.000015     syn region rustCommentLinesDocNonRustCode matchgroup=rustCommentDocCodeFence start='^\z(\s*//[!/]\s*```\).\+$' end='^\z1$' keepend contains=rustCommentLineDoc
                            
                                " We borrow the rules from rust’s src/librustdoc/html/markdown.rs, so that
                                " we only highlight as Rust what it would perceive as Rust (almost; it’s
                                " possible to trick it if you try hard, and indented code blocks aren’t
                                " supported because Markdown is a menace to parse and only mad dogs and
                                " Englishmen would try to handle that case correctly in this syntax file).
    1              0.000038     syn region rustCommentLinesDocRustCode matchgroup=rustCommentDocCodeFence start='^\z(\s*//[!/]\s*```\)[^A-Za-z0-9_-]*\%(\%(should_panic\|no_run\|ignore\|allow_fail\|rust\|test_harness\|compile_fail\|E\d\{4}\|edition201[58]\)\%([^A-Za-z0-9_-]\+\|$\)\)*$' end='^\z1$' keepend contains=@RustCodeInComment,rustCommentLineDocLeader
    1              0.000037     syn region rustCommentBlockDocRustCode matchgroup=rustCommentDocCodeFence start='^\z(\%(\s*\*\)\?\s*```\)[^A-Za-z0-9_-]*\%(\%(should_panic\|no_run\|ignore\|allow_fail\|rust\|test_harness\|compile_fail\|E\d\{4}\|edition201[58]\)\%([^A-Za-z0-9_-]\+\|$\)\)*$' end='^\z1$' keepend contains=@RustCodeInComment,rustCommentBlockDocStar
                                " Strictly, this may or may not be correct; this code, for example, would
                                " mishighlight:
                                "
                                "     /**
                                "     ```rust
                                "     println!("{}", 1
                                "     * 1);
                                "     ```
                                "     */
                                "
                                " … but I don’t care. Balance of probability, and all that.
    1              0.000006     syn match rustCommentBlockDocStar /^\s*\*\s\?/ contained
    1              0.000005     syn match rustCommentLineDocLeader "^\s*//\%(//\@!\|!\)" contained
    2              0.000003 endif
                            
                            " Default highlighting {{{1
    2              0.000007 hi def link rustDecNumber       rustNumber
    2              0.000004 hi def link rustHexNumber       rustNumber
    2              0.000004 hi def link rustOctNumber       rustNumber
    2              0.000004 hi def link rustBinNumber       rustNumber
    2              0.000005 hi def link rustIdentifierPrime rustIdentifier
    2              0.000004 hi def link rustTrait           rustType
    2              0.000005 hi def link rustDeriveTrait     rustTrait
                            
    2              0.000005 hi def link rustMacroRepeatDelimiters   Macro
    2              0.000004 hi def link rustMacroVariable Define
    2              0.000004 hi def link rustSigil         StorageClass
    2              0.000004 hi def link rustEscape        Special
    2              0.000004 hi def link rustEscapeUnicode rustEscape
    2              0.000004 hi def link rustEscapeError   Error
    2              0.000004 hi def link rustStringContinuation Special
    2              0.000004 hi def link rustString        String
    2              0.000004 hi def link rustStringDelimiter String
    2              0.000003 hi def link rustCharacterInvalid Error
    2              0.000005 hi def link rustCharacterInvalidUnicode rustCharacterInvalid
    2              0.000004 hi def link rustCharacter     Character
    2              0.000004 hi def link rustNumber        Number
    2              0.000003 hi def link rustBoolean       Boolean
    2              0.000004 hi def link rustEnum          rustType
    2              0.000004 hi def link rustEnumVariant   rustConstant
    2              0.000004 hi def link rustConstant      Constant
    2              0.000004 hi def link rustSelf          Constant
    2              0.000004 hi def link rustFloat         Float
    2              0.000005 hi def link rustArrowCharacter rustOperator
    2              0.000004 hi def link rustOperator      Operator
    2              0.000004 hi def link rustKeyword       Keyword
    2              0.000009 hi def link rustDynKeyword    rustKeyword
    2              0.000004 hi def link rustTypedef       Keyword " More precise is Typedef, but it doesn't feel right for Rust
    2              0.000004 hi def link rustStructure     Keyword " More precise is Structure
    2              0.000004 hi def link rustUnion         rustStructure
    2              0.000005 hi def link rustExistential   rustKeyword
    2              0.000004 hi def link rustPubScopeDelim Delimiter
    2              0.000004 hi def link rustPubScopeCrate rustKeyword
    2              0.000004 hi def link rustSuper         rustKeyword
    2              0.000003 hi def link rustUnsafeKeyword Exception
    2              0.000004 hi def link rustReservedKeyword Error
    2              0.000004 hi def link rustRepeat        Conditional
    2              0.000004 hi def link rustConditional   Conditional
    2              0.000004 hi def link rustIdentifier    Identifier
    2              0.000004 hi def link rustCapsIdent     rustIdentifier
    2              0.000004 hi def link rustModPath       Include
    2              0.000004 hi def link rustModPathSep    Delimiter
    2              0.000004 hi def link rustFunction      Function
    2              0.000004 hi def link rustFuncName      Function
    2              0.000005 hi def link rustFuncCall      Function
    2              0.000003 hi def link rustShebang       Comment
    2              0.000004 hi def link rustCommentLine   Comment
    2              0.000004 hi def link rustCommentLineDoc SpecialComment
    2              0.000004 hi def link rustCommentLineDocLeader rustCommentLineDoc
    2              0.000004 hi def link rustCommentLineDocError Error
    2              0.000004 hi def link rustCommentBlock  rustCommentLine
    2              0.000005 hi def link rustCommentBlockDoc rustCommentLineDoc
    2              0.000004 hi def link rustCommentBlockDocStar rustCommentBlockDoc
    2              0.000004 hi def link rustCommentBlockDocError Error
    2              0.000004 hi def link rustCommentDocCodeFence rustCommentLineDoc
    2              0.000003 hi def link rustAssert        PreCondit
    2              0.000005 hi def link rustPanic         PreCondit
    2              0.000004 hi def link rustMacro         Macro
    2              0.000004 hi def link rustType          Type
    2              0.000004 hi def link rustTodo          Todo
    2              0.000004 hi def link rustAttribute     PreProc
    2              0.000005 hi def link rustDerive        PreProc
    2              0.000004 hi def link rustDefault       StorageClass
    2              0.000004 hi def link rustStorage       StorageClass
    2              0.000005 hi def link rustObsoleteStorage Error
    2              0.000003 hi def link rustLifetime      Special
    2              0.000003 hi def link rustLabel         Label
    2              0.000004 hi def link rustExternCrate   rustKeyword
    2              0.000004 hi def link rustObsoleteExternMod Error
    2              0.000004 hi def link rustQuestionMark  Special
    2              0.000004 hi def link rustAsync         rustKeyword
    2              0.000004 hi def link rustAwait         rustKeyword
    2              0.000004 hi def link rustAsmDirSpec    rustKeyword
    2              0.000004 hi def link rustAsmSym        rustKeyword
    2              0.000004 hi def link rustAsmOptions    rustKeyword
    2              0.000004 hi def link rustAsmOptionsKey rustAttribute
                            
                            " Other Suggestions:
                            " hi rustAttribute ctermfg=cyan
                            " hi rustDerive ctermfg=cyan
                            " hi rustAssert ctermfg=yellow
                            " hi rustPanic ctermfg=red
                            " hi rustMacro ctermfg=magenta
                            
    2              0.000005 syn sync minlines=200
    2              0.000005 syn sync maxlines=500
                            
    2              0.000010 let b:current_syntax = "rust"
                            
                            " vim: set et sw=4 sts=4 ts=8:

SCRIPT  /usr/share/nvim/runtime/autoload/rustfmt.vim
Sourced 1 time
Total time:   0.122087
 Self time:   0.008288

count  total (s)   self (s)
                            " Author: Stephen Sugden <stephen@stephensugden.com>
                            " Last Modified: 2023-09-11
                            "
                            " Adapted from https://github.com/fatih/vim-go
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
    1              0.000018 if !exists("g:rustfmt_autosave")
    1              0.000010     let g:rustfmt_autosave = 0
    1              0.000002 endif
                            
    1              0.000005 if !exists("g:rustfmt_command")
    1              0.000007     let g:rustfmt_command = "rustfmt"
    1              0.000001 endif
                            
    1              0.000005 if !exists("g:rustfmt_options")
    1              0.000004     let g:rustfmt_options = ""
    1              0.000001 endif
                            
    1              0.000005 if !exists("g:rustfmt_fail_silently")
    1              0.000005     let g:rustfmt_fail_silently = 0
    1              0.000001 endif
                            
    1              0.000005 function! rustfmt#DetectVersion()
                                " Save rustfmt '--help' for feature inspection
                                silent let s:rustfmt_help = system(g:rustfmt_command . " --help")
                                let s:rustfmt_unstable_features = s:rustfmt_help =~# "--unstable-features"
                            
                                " Build a comparable rustfmt version variable out of its `--version` output:
                                silent let l:rustfmt_version_full = system(g:rustfmt_command . " --version")
                                let l:rustfmt_version_list = matchlist(l:rustfmt_version_full,
                                    \    '\vrustfmt ([0-9]+[.][0-9]+[.][0-9]+)')
                                if len(l:rustfmt_version_list) < 3
                                    let s:rustfmt_version = "0"
                                else
                                    let s:rustfmt_version = l:rustfmt_version_list[1]
                                endif
                                return s:rustfmt_version
                            endfunction
                            
    1   0.113838   0.000039 call rustfmt#DetectVersion()
                            
    1              0.000005 if !exists("g:rustfmt_emit_files")
    1              0.000010     let g:rustfmt_emit_files = s:rustfmt_version >= "0.8.2"
    1              0.000001 endif
                            
    1              0.000004 if !exists("g:rustfmt_file_lines")
    1              0.000020     let g:rustfmt_file_lines = s:rustfmt_help =~# "--file-lines JSON"
    1              0.000001 endif
                            
    1              0.000002 let s:got_fmt_error = 0
                            
    1              0.000005 function! rustfmt#Load()
                                " Utility call to get this script loaded, for debugging
                            endfunction
                            
    1              0.000004 function! s:RustfmtWriteMode()
                                if g:rustfmt_emit_files
                                    return "--emit=files"
                                else
                                    return "--write-mode=overwrite"
                                endif
                            endfunction
                            
    1              0.000002 function! s:RustfmtConfigOptions()
                                let l:rustfmt_toml = findfile('rustfmt.toml', expand('%:p:h') . ';')
                                if l:rustfmt_toml !=# ''
                                    return '--config-path '.shellescape(fnamemodify(l:rustfmt_toml, ":p"))
                                endif
                            
                                let l:_rustfmt_toml = findfile('.rustfmt.toml', expand('%:p:h') . ';')
                                if l:_rustfmt_toml !=# ''
                                    return '--config-path '.shellescape(fnamemodify(l:_rustfmt_toml, ":p"))
                                endif
                            
                                " Default to edition 2018 in case no rustfmt.toml was found.
                                return '--edition 2018'
                            endfunction
                            
    1              0.000008 function! s:RustfmtCommandRange(filename, line1, line2)
                                if g:rustfmt_file_lines == 0
                                    echo "--file-lines is not supported in the installed `rustfmt` executable"
                                    return
                                endif
                            
                                let l:arg = {"file": shellescape(a:filename), "range": [a:line1, a:line2]}
                                let l:write_mode = s:RustfmtWriteMode()
                                let l:rustfmt_config = s:RustfmtConfigOptions()
                            
                                " FIXME: When --file-lines gets to be stable, add version range checking
                                " accordingly.
                                let l:unstable_features = s:rustfmt_unstable_features ? '--unstable-features' : ''
                            
                                let l:cmd = printf("%s %s %s %s %s --file-lines '[%s]' %s", g:rustfmt_command,
                                            \ l:write_mode, g:rustfmt_options,
                                            \ l:unstable_features, l:rustfmt_config,
                                            \ json_encode(l:arg), shellescape(a:filename))
                                return l:cmd
                            endfunction
                            
    1              0.000002 function! s:RustfmtCommand()
                                let write_mode = g:rustfmt_emit_files ? '--emit=stdout' : '--write-mode=display'
                                let config = s:RustfmtConfigOptions()
                                return join([g:rustfmt_command, write_mode, config, g:rustfmt_options])
                            endfunction
                            
    1              0.000007 function! s:DeleteLines(start, end) abort
                                silent! execute a:start . ',' . a:end . 'delete _'
                            endfunction
                            
    1              0.000002 function! s:RunRustfmt(command, tmpname, from_writepre)
                                let l:view = winsaveview()
                            
                                let l:stderr_tmpname = tempname()
                                call writefile([], l:stderr_tmpname)
                            
                                let l:command = a:command . ' 2> ' . l:stderr_tmpname
                            
                                if a:tmpname ==# ''
                                    " Rustfmt in stdin/stdout mode
                            
                                    " chdir to the directory of the file
                                    let l:has_lcd = haslocaldir()
                                    let l:prev_cd = getcwd()
                                    execute 'lchdir! '.expand('%:h')
                            
                                    let l:buffer = getline(1, '$')
                                    if exists("*systemlist")
                                        silent let out = systemlist(l:command, l:buffer)
                                    else
                                        silent let out = split(system(l:command,
                                                    \ join(l:buffer, "\n")), '\r\?\n')
                                    endif
                                else
                                    if exists("*systemlist")
                                        silent let out = systemlist(l:command)
                                    else
                                        silent let out = split(system(l:command), '\r\?\n')
                                    endif
                                endif
                            
                                let l:stderr = readfile(l:stderr_tmpname)
                            
                                call delete(l:stderr_tmpname)
                            
                                let l:open_lwindow = 0
                                if v:shell_error == 0
                                    if a:from_writepre
                                        " remove undo point caused via BufWritePre
                                        try | silent undojoin | catch | endtry
                                    endif
                            
                                    if a:tmpname ==# ''
                                        let l:content = l:out
                                    else
                                        " take the tmpfile's content, this is better than rename
                                        " because it preserves file modes.
                                        let l:content = readfile(a:tmpname)
                                    endif
                            
                                    call s:DeleteLines(len(l:content), line('$'))
                                    call setline(1, l:content)
                            
                                    " only clear location list if it was previously filled to prevent
                                    " clobbering other additions
                                    if s:got_fmt_error
                                        let s:got_fmt_error = 0
                                        call setloclist(0, [])
                                        let l:open_lwindow = 1
                                    endif
                                elseif g:rustfmt_fail_silently == 0 && !a:from_writepre
                                    " otherwise get the errors and put them in the location list
                                    let l:errors = []
                            
                                    let l:prev_line = ""
                                    for l:line in l:stderr
                                        " error: expected one of `;` or `as`, found `extern`
                                        "  --> src/main.rs:2:1
                                        let tokens = matchlist(l:line, '^\s\+-->\s\(.\{-}\):\(\d\+\):\(\d\+\)$')
                                        if !empty(tokens)
                                            call add(l:errors, {"filename": @%,
                                                        \"lnum":	tokens[2],
                                                        \"col":	tokens[3],
                                                        \"text":	l:prev_line})
                                        endif
                                        let l:prev_line = l:line
                                    endfor
                            
                                    if !empty(l:errors)
                                        call setloclist(0, l:errors, 'r')
                                        echohl Error | echomsg "rustfmt returned error" | echohl None
                                    else
                                        echo "rust.vim: was not able to parse rustfmt messages. Here is the raw output:"
                                        echo "\n"
                                        for l:line in l:stderr
                                            echo l:line
                                        endfor
                                    endif
                            
                                    let s:got_fmt_error = 1
                                    let l:open_lwindow = 1
                                endif
                            
                                " Restore the current directory if needed
                                if a:tmpname ==# ''
                                    if l:has_lcd
                                        execute 'lchdir! '.l:prev_cd
                                    else
                                        execute 'chdir! '.l:prev_cd
                                    endif
                                endif
                            
                                " Open lwindow after we have changed back to the previous directory
                                if l:open_lwindow == 1
                                    lwindow
                                endif
                            
                                call winrestview(l:view)
                            endfunction
                            
    1              0.000002 function! rustfmt#FormatRange(line1, line2)
                                let l:tmpname = tempname()
                                call writefile(getline(1, '$'), l:tmpname)
                                let command = s:RustfmtCommandRange(l:tmpname, a:line1, a:line2)
                                call s:RunRustfmt(command, l:tmpname, v:false)
                                call delete(l:tmpname)
                            endfunction
                            
    1              0.000001 function! rustfmt#Format()
                                call s:RunRustfmt(s:RustfmtCommand(), '', v:false)
                            endfunction
                            
    1              0.000001 function! rustfmt#Cmd()
                                " Mainly for debugging
                                return s:RustfmtCommand()
                            endfunction
                            
    1              0.000001 function! rustfmt#PreWrite()
                                if !filereadable(expand("%@"))
                                    return
                                endif
                                if rust#GetConfigVar('rustfmt_autosave_if_config_present', 0)
                                    if findfile('rustfmt.toml', '.;') !=# '' || findfile('.rustfmt.toml', '.;') !=# ''
                                        let b:rustfmt_autosave = 1
                                        let b:_rustfmt_autosave_because_of_config = 1
                                    endif
                                else
                                    if has_key(b:, '_rustfmt_autosave_because_of_config')
                                        unlet b:_rustfmt_autosave_because_of_config
                                        unlet b:rustfmt_autosave
                                    endif
                                endif
                            
                                if !rust#GetConfigVar("rustfmt_autosave", 0)
                                    return
                                endif
                            
                                call s:RunRustfmt(s:RustfmtCommand(), '', v:true)
                            endfunction
                            
                            
                            " vim: set et sw=4 sts=4 ts=8:

SCRIPT  /usr/share/nvim/runtime/autoload/rust.vim
Sourced 1 time
Total time:   0.008100
 Self time:   0.008100

count  total (s)   self (s)
                            " Description: Helper functions for Rust commands/mappings
                            " Last Modified: 2023-09-11
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
    1              0.000002 function! rust#Load()
                                " Utility call to get this script loaded, for debugging
                            endfunction
                            
    1              0.000002 function! rust#GetConfigVar(name, default)
                                " Local buffer variable with same name takes predeence over global
                                if has_key(b:, a:name)
                                    return get(b:, a:name)
                                endif
                                if has_key(g:, a:name)
                                    return get(g:, a:name)
                                endif
                                return a:default
                            endfunction
                            
                            " Include expression {{{1
                            
    1              0.000001 function! rust#IncludeExpr(fname) abort
                                " Remove leading 'crate::' to deal with 2018 edition style 'use'
                                " statements
                                let l:fname = substitute(a:fname, '^crate::', '', '')
                            
                                " Remove trailing colons arising from lines like
                                "
                                "     use foo::{Bar, Baz};
                                let l:fname = substitute(l:fname, ':\+$', '', '')
                            
                                " Replace '::' with '/'
                                let l:fname = substitute(l:fname, '::', '/', 'g')
                            
                                " When we have
                                "
                                "    use foo::bar::baz;
                                "
                                " we can't tell whether baz is a module or a function; and we can't tell
                                " which modules correspond to files.
                                "
                                " So we work our way up, trying
                                "
                                "     foo/bar/baz.rs
                                "     foo/bar.rs
                                "     foo.rs
                                while l:fname !=# '.'
                                    let l:path = findfile(l:fname)
                                    if !empty(l:path)
                                        return l:fname
                                    endif
                                    let l:fname = fnamemodify(l:fname, ':h')
                                endwhile
                                return l:fname
                            endfunction
                            
                            " Jump {{{1
                            
    1              0.000001 function! rust#Jump(mode, function) range
                                let cnt = v:count1
                                normal! m'
                                if a:mode ==# 'v'
                                    norm! gv
                                endif
                                let foldenable = &foldenable
                                set nofoldenable
                                while cnt > 0
                                    execute "call <SID>Jump_" . a:function . "()"
                                    let cnt = cnt - 1
                                endwhile
                                let &foldenable = foldenable
                            endfunction
                            
    1              0.000002 function! s:Jump_Back()
                                call search('{', 'b')
                                keepjumps normal! w99[{
                            endfunction
                            
    1              0.000001 function! s:Jump_Forward()
                                normal! j0
                                call search('{', 'b')
                                keepjumps normal! w99[{%
                                call search('{')
                            endfunction
                            
                            " Run {{{1
                            
    1              0.000001 function! rust#Run(bang, args)
                                let args = s:ShellTokenize(a:args)
                                if a:bang
                                    let idx = index(l:args, '--')
                                    if idx != -1
                                        let rustc_args = idx == 0 ? [] : l:args[:idx-1]
                                        let args = l:args[idx+1:]
                                    else
                                        let rustc_args = l:args
                                        let args = []
                                    endif
                                else
                                    let rustc_args = []
                                endif
                            
                                let b:rust_last_rustc_args = l:rustc_args
                                let b:rust_last_args = l:args
                            
                                call s:WithPath(function("s:Run"), rustc_args, args)
                            endfunction
                            
    1              0.000001 function! s:Run(dict, rustc_args, args)
                                let exepath = a:dict.tmpdir.'/'.fnamemodify(a:dict.path, ':t:r')
                                if has('win32')
                                    let exepath .= '.exe'
                                endif
                            
                                let relpath = get(a:dict, 'tmpdir_relpath', a:dict.path)
                                let rustc_args = [relpath, '-o', exepath] + a:rustc_args
                            
                                let rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"
                            
                                let pwd = a:dict.istemp ? a:dict.tmpdir : ''
                                let output = s:system(pwd, shellescape(rustc) . " " . join(map(rustc_args, 'shellescape(v:val)')))
                                if output !=# ''
                                    echohl WarningMsg
                                    echo output
                                    echohl None
                                endif
                                if !v:shell_error
                                    exe '!' . shellescape(exepath) . " " . join(map(a:args, 'shellescape(v:val)'))
                                endif
                            endfunction
                            
                            " Expand {{{1
                            
    1              0.000001 function! rust#Expand(bang, args)
                                let args = s:ShellTokenize(a:args)
                                if a:bang && !empty(l:args)
                                    let pretty = remove(l:args, 0)
                                else
                                    let pretty = "expanded"
                                endif
                                call s:WithPath(function("s:Expand"), pretty, args)
                            endfunction
                            
    1              0.000001 function! s:Expand(dict, pretty, args)
                                try
                                    let rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"
                            
                                    if a:pretty =~? '^\%(everybody_loops$\|flowgraph=\)'
                                        let flag = '--xpretty'
                                    else
                                        let flag = '--pretty'
                                    endif
                                    let relpath = get(a:dict, 'tmpdir_relpath', a:dict.path)
                                    let args = [relpath, '-Z', 'unstable-options', l:flag, a:pretty] + a:args
                                    let pwd = a:dict.istemp ? a:dict.tmpdir : ''
                                    let output = s:system(pwd, shellescape(rustc) . " " . join(map(args, 'shellescape(v:val)')))
                                    if v:shell_error
                                        echohl WarningMsg
                                        echo output
                                        echohl None
                                    else
                                        new
                                        silent put =output
                                        1
                                        d
                                        setl filetype=rust
                                        setl buftype=nofile
                                        setl bufhidden=hide
                                        setl noswapfile
                                        " give the buffer a nice name
                                        let suffix = 1
                                        let basename = fnamemodify(a:dict.path, ':t:r')
                                        while 1
                                            let bufname = basename
                                            if suffix > 1 | let bufname .= ' ('.suffix.')' | endif
                                            let bufname .= '.pretty.rs'
                                            if bufexists(bufname)
                                                let suffix += 1
                                                continue
                                            endif
                                            exe 'silent noautocmd keepalt file' fnameescape(bufname)
                                            break
                                        endwhile
                                    endif
                                endtry
                            endfunction
                            
    1              0.000001 function! rust#CompleteExpand(lead, line, pos)
                                if a:line[: a:pos-1] =~# '^RustExpand!\s*\S*$'
                                    " first argument and it has a !
                                    let list = ["normal", "expanded", "typed", "expanded,identified", "flowgraph=", "everybody_loops"]
                                    if !empty(a:lead)
                                        call filter(list, "v:val[:len(a:lead)-1] == a:lead")
                                    endif
                                    return list
                                endif
                            
                                return glob(escape(a:lead, "*?[") . '*', 0, 1)
                            endfunction
                            
                            " Emit {{{1
                            
    1              0.000001 function! rust#Emit(type, args)
                                let args = s:ShellTokenize(a:args)
                                call s:WithPath(function("s:Emit"), a:type, args)
                            endfunction
                            
    1              0.000001 function! s:Emit(dict, type, args)
                                try
                                    let output_path = a:dict.tmpdir.'/output'
                            
                                    let rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"
                            
                                    let relpath = get(a:dict, 'tmpdir_relpath', a:dict.path)
                                    let args = [relpath, '--emit', a:type, '-o', output_path] + a:args
                                    let pwd = a:dict.istemp ? a:dict.tmpdir : ''
                                    let output = s:system(pwd, shellescape(rustc) . " " . join(map(args, 'shellescape(v:val)')))
                                    if output !=# ''
                                        echohl WarningMsg
                                        echo output
                                        echohl None
                                    endif
                                    if !v:shell_error
                                        new
                                        exe 'silent keepalt read' fnameescape(output_path)
                                        1
                                        d
                                        if a:type ==# "llvm-ir"
                                            setl filetype=llvm
                                            let extension = 'll'
                                        elseif a:type ==# "asm"
                                            setl filetype=asm
                                            let extension = 's'
                                        endif
                                        setl buftype=nofile
                                        setl bufhidden=hide
                                        setl noswapfile
                                        if exists('l:extension')
                                            " give the buffer a nice name
                                            let suffix = 1
                                            let basename = fnamemodify(a:dict.path, ':t:r')
                                            while 1
                                                let bufname = basename
                                                if suffix > 1 | let bufname .= ' ('.suffix.')' | endif
                                                let bufname .= '.'.extension
                                                if bufexists(bufname)
                                                    let suffix += 1
                                                    continue
                                                endif
                                                exe 'silent noautocmd keepalt file' fnameescape(bufname)
                                                break
                                            endwhile
                                        endif
                                    endif
                                endtry
                            endfunction
                            
                            " Utility functions {{{1
                            
                            " Invokes func(dict, ...)
                            " Where {dict} is a dictionary with the following keys:
                            "   'path' - The path to the file
                            "   'tmpdir' - The path to a temporary directory that will be deleted when the
                            "              function returns.
                            "   'istemp' - 1 if the path is a file inside of {dict.tmpdir} or 0 otherwise.
                            " If {istemp} is 1 then an additional key is provided:
                            "   'tmpdir_relpath' - The {path} relative to the {tmpdir}.
                            "
                            " {dict.path} may be a path to a file inside of {dict.tmpdir} or it may be the
                            " existing path of the current buffer. If the path is inside of {dict.tmpdir}
                            " then it is guaranteed to have a '.rs' extension.
    1              0.000001 function! s:WithPath(func, ...)
                                let buf = bufnr('')
                                let saved = {}
                                let dict = {}
                                try
                                    let saved.write = &write
                                    set write
                                    let dict.path = expand('%')
                                    let pathisempty = empty(dict.path)
                            
                                    " Always create a tmpdir in case the wrapped command wants it
                                    let dict.tmpdir = tempname()
                                    call mkdir(dict.tmpdir)
                            
                                    if pathisempty || !saved.write
                                        let dict.istemp = 1
                                        " if we're doing this because of nowrite, preserve the filename
                                        if !pathisempty
                                            let filename = expand('%:t:r').".rs"
                                        else
                                            let filename = 'unnamed.rs'
                                        endif
                                        let dict.tmpdir_relpath = filename
                                        let dict.path = dict.tmpdir.'/'.filename
                            
                                        let saved.mod = &modified
                                        set nomodified
                            
                                        silent exe 'keepalt write! ' . fnameescape(dict.path)
                                        if pathisempty
                                            silent keepalt 0file
                                        endif
                                    else
                                        let dict.istemp = 0
                                        update
                                    endif
                            
                                    call call(a:func, [dict] + a:000)
                                finally
                                    if bufexists(buf)
                                        for [opt, value] in items(saved)
                                            silent call setbufvar(buf, '&'.opt, value)
                                            unlet value " avoid variable type mismatches
                                        endfor
                                    endif
                                    if has_key(dict, 'tmpdir') | silent call s:RmDir(dict.tmpdir) | endif
                                endtry
                            endfunction
                            
    1              0.000006 function! rust#AppendCmdLine(text)
                                call setcmdpos(getcmdpos())
                                let cmd = getcmdline() . a:text
                                return cmd
                            endfunction
                            
                            " Tokenize the string according to sh parsing rules
    1              0.000003 function! s:ShellTokenize(text)
                                " states:
                                " 0: start of word
                                " 1: unquoted
                                " 2: unquoted backslash
                                " 3: double-quote
                                " 4: double-quoted backslash
                                " 5: single-quote
                                let l:state = 0
                                let l:current = ''
                                let l:args = []
                                for c in split(a:text, '\zs')
                                    if l:state == 0 || l:state == 1 " unquoted
                                        if l:c ==# ' '
                                            if l:state == 0 | continue | endif
                                            call add(l:args, l:current)
                                            let l:current = ''
                                            let l:state = 0
                                        elseif l:c ==# '\'
                                            let l:state = 2
                                        elseif l:c ==# '"'
                                            let l:state = 3
                                        elseif l:c ==# "'"
                                            let l:state = 5
                                        else
                                            let l:current .= l:c
                                            let l:state = 1
                                        endif
                                    elseif l:state == 2 " unquoted backslash
                                        if l:c !=# "\n" " can it even be \n?
                                            let l:current .= l:c
                                        endif
                                        let l:state = 1
                                    elseif l:state == 3 " double-quote
                                        if l:c ==# '\'
                                            let l:state = 4
                                        elseif l:c ==# '"'
                                            let l:state = 1
                                        else
                                            let l:current .= l:c
                                        endif
                                    elseif l:state == 4 " double-quoted backslash
                                        if stridx('$`"\', l:c) >= 0
                                            let l:current .= l:c
                                        elseif l:c ==# "\n" " is this even possible?
                                            " skip it
                                        else
                                            let l:current .= '\'.l:c
                                        endif
                                        let l:state = 3
                                    elseif l:state == 5 " single-quoted
                                        if l:c ==# "'"
                                            let l:state = 1
                                        else
                                            let l:current .= l:c
                                        endif
                                    endif
                                endfor
                                if l:state != 0
                                    call add(l:args, l:current)
                                endif
                                return l:args
                            endfunction
                            
    1              0.000001 function! s:RmDir(path)
                                " sanity check; make sure it's not empty, /, or $HOME
                                if empty(a:path)
                                    echoerr 'Attempted to delete empty path'
                                    return 0
                                elseif a:path ==# '/' || a:path ==# $HOME
                                    let l:path = expand(a:path)
                                    if l:path ==# '/' || l:path ==# $HOME
                                        echoerr 'Attempted to delete protected path: ' . a:path
                                        return 0
                                    endif
                                endif
                            
                                if !isdirectory(a:path)
                                    return 0
                                endif
                            
                                " delete() returns 0 when removing file successfully
                                return delete(a:path, 'rf') == 0
                            endfunction
                            
                            " Executes {cmd} with the cwd set to {pwd}, without changing Vim's cwd.
                            " If {pwd} is the empty string then it doesn't change the cwd.
    1              0.000001 function! s:system(pwd, cmd)
                                let cmd = a:cmd
                                if !empty(a:pwd)
                                    let cmd = 'cd ' . shellescape(a:pwd) . ' && ' . cmd
                                endif
                                return system(cmd)
                            endfunction
                            
                            " Playpen Support {{{1
                            " Parts of gist.vim by Yasuhiro Matsumoto <mattn.jp@gmail.com> reused
                            " gist.vim available under the BSD license, available at
                            " http://github.com/mattn/gist-vim
    1              0.000001 function! s:has_webapi()
                                if !exists("*webapi#http#post")
                                    try
                                        call webapi#http#post()
                                    catch
                                    endtry
                                endif
                                return exists("*webapi#http#post")
                            endfunction
                            
    1              0.000001 function! rust#Play(count, line1, line2, ...) abort
                                redraw
                            
                                let l:rust_playpen_url = get(g:, 'rust_playpen_url', 'https://play.rust-lang.org/')
                                let l:rust_shortener_url = get(g:, 'rust_shortener_url', 'https://is.gd/')
                            
                                if !s:has_webapi()
                                    echohl ErrorMsg | echomsg ':RustPlay depends on webapi.vim (https://github.com/mattn/webapi-vim)' | echohl None
                                    return
                                endif
                            
                                let bufname = bufname('%')
                                if a:count < 1
                                    let content = join(getline(a:line1, a:line2), "\n")
                                else
                                    let save_regcont = @"
                                    let save_regtype = getregtype('"')
                                    silent! normal! gvy
                                    let content = @"
                                    call setreg('"', save_regcont, save_regtype)
                                endif
                            
                                let url = l:rust_playpen_url."?code=".webapi#http#encodeURI(content)
                            
                                if strlen(url) > 5000
                                    echohl ErrorMsg | echomsg 'Buffer too large, max 5000 encoded characters ('.strlen(url).')' | echohl None
                                    return
                                endif
                            
                                let payload = "format=simple&url=".webapi#http#encodeURI(url)
                                let res = webapi#http#post(l:rust_shortener_url.'create.php', payload, {})
                                if res.status[0] ==# '2'
                                    let url = res.content
                                endif
                            
                                let footer = ''
                                if exists('g:rust_clip_command')
                                    call system(g:rust_clip_command, url)
                                    if !v:shell_error
                                        let footer = ' (copied to clipboard)'
                                    endif
                                endif
                                redraw | echomsg 'Done: '.url.footer
                            endfunction
                            
                            " Run a test under the cursor or all tests {{{1
                            
                            " Finds a test function name under the cursor. Returns empty string when a
                            " test function is not found.
    1              0.000002 function! s:SearchTestFunctionNameUnderCursor() abort
                                let cursor_line = line('.')
                            
                                " Find #[test] attribute
                                if search('\m\C#\[test\]', 'bcW') is 0
                                    return ''
                                endif
                            
                                " Move to an opening brace of the test function
                                let test_func_line = search('\m\C^\s*fn\s\+\h\w*\s*(.\+{$', 'eW')
                                if test_func_line is 0
                                    return ''
                                endif
                            
                                " Search the end of test function (closing brace) to ensure that the
                                " cursor position is within function definition
                                if maparg('<Plug>(MatchitNormalForward)') ==# ''
                                    keepjumps normal! %
                                else
                                    " Prefer matchit.vim official plugin to native % since the plugin
                                    " provides better behavior than original % (#391)
                                    " To load the plugin, run:
                                    "   :packadd matchit
                                    execute 'keepjumps' 'normal' "\<Plug>(MatchitNormalForward)"
                                endif
                                if line('.') < cursor_line
                                    return ''
                                endif
                            
                                return matchstr(getline(test_func_line), '\m\C^\s*fn\s\+\zs\h\w*')
                            endfunction
                            
    1              0.000002 function! rust#Test(mods, winsize, all, options) abort
                                let manifest = findfile('Cargo.toml', expand('%:p:h') . ';')
                                if manifest ==# ''
                                    return rust#Run(1, '--test ' . a:options)
                                endif
                            
                                " <count> defaults to 0, but we prefer an empty string
                                let winsize = a:winsize ? a:winsize : ''
                            
                                if has('terminal')
                                    if has('patch-8.0.910')
                                        let cmd = printf('%s noautocmd %snew | terminal ++curwin ', a:mods, winsize)
                                    else
                                        let cmd = printf('%s terminal ', a:mods)
                                    endif
                                elseif has('nvim')
                                    let cmd = printf('%s noautocmd %snew | terminal ', a:mods, winsize)
                                else
                                    let cmd = '!'
                                    let manifest = shellescape(manifest)
                                endif
                            
                                if a:all
                                    if a:options ==# ''
                                        execute cmd . 'cargo test --manifest-path' manifest
                                    else
                                        execute cmd . 'cargo test --manifest-path' manifest a:options
                                    endif
                                    return
                                endif
                            
                                let saved = getpos('.')
                                try
                                    let func_name = s:SearchTestFunctionNameUnderCursor()
                                finally
                                    call setpos('.', saved)
                                endtry
                                if func_name ==# ''
                                    echohl ErrorMsg
                                    echomsg 'No test function was found under the cursor. Please add ! to command if you want to run all tests'
                                    echohl None
                                    return
                                endif
                                if a:options ==# ''
                                    execute cmd . 'cargo test --manifest-path' manifest func_name
                                else
                                    execute cmd . 'cargo test --manifest-path' manifest func_name a:options
                                endif
                            endfunction
                            
                            " }}}1
                            
                            " vim: set et sw=4 sts=4 ts=8:

FUNCTION  rustfmt#DetectVersion()
    Defined: /usr/share/nvim/runtime/autoload/rustfmt.vim:23
Called 1 time
Total time:   0.113798
 Self time:   0.000178

count  total (s)   self (s)
                                " Save rustfmt '--help' for feature inspection
    1   0.068629   0.000035     silent let s:rustfmt_help = system(g:rustfmt_command . " --help")
    1              0.000029     let s:rustfmt_unstable_features = s:rustfmt_help =~# "--unstable-features"
                            
                                " Build a comparable rustfmt version variable out of its `--version` output:
    1   0.045059   0.000033     silent let l:rustfmt_version_full = system(g:rustfmt_command . " --version")
    1              0.000050     let l:rustfmt_version_list = matchlist(l:rustfmt_version_full,    '\vrustfmt ([0-9]+[.][0-9]+[.][0-9]+)')
    1              0.000005     if len(l:rustfmt_version_list) < 3
                                    let s:rustfmt_version = "0"
    1              0.000001     else
    1              0.000005         let s:rustfmt_version = l:rustfmt_version_list[1]
    1              0.000001     endif
    1              0.000004     return s:rustfmt_version

FUNCTION  <SNR>35_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:206
Called 1264 times
Total time:   0.043885
 Self time:   0.043885

count  total (s)   self (s)
 1264              0.010337   if exists('w:paren_hl_on') && w:paren_hl_on
  302              0.002064     while !empty(w:matchparen_ids)
  151              0.002707       silent! call remove(w:matchparen_ids, 0)->matchdelete()
  302              0.000968     endwhile
  151              0.000976     let w:paren_hl_on = 0
 1264              0.001541   endif

FUNCTION  <SNR>55_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:27
Called 35 times
Total time:   0.102379
 Self time:   0.091637

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   35              0.000244   syn clear
   35              0.000166   if exists("b:current_syntax")
                                unlet b:current_syntax
   35              0.000053   endif
                            
   35              0.000225   0verbose let s = expand("<amatch>")
   35              0.000089   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   35              0.000076   elseif s == "OFF"
                                let s = ""
   35              0.000026   endif
                            
   35              0.000057   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   70              0.000513     for name in split(s, '\.')
   35              0.000115       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   35   0.099407   0.088665         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
   35              0.000119       endif
   70              0.000105     endfor
   35              0.000046   endif

FUNCTION  rust#GetConfigVar()
    Defined: /usr/share/nvim/runtime/autoload/rust.vim:9
Called 12 times
Total time:   0.000433
 Self time:   0.000433

count  total (s)   self (s)
                                " Local buffer variable with same name takes predeence over global
   12              0.000098     if has_key(b:, a:name)
                                    return get(b:, a:name)
   12              0.000041     endif
   12              0.000071     if has_key(g:, a:name)
    6              0.000038         return get(g:, a:name)
    6              0.000007     endif
    6              0.000024     return a:default

FUNCTION  rustfmt#PreWrite()
    Defined: /usr/share/nvim/runtime/autoload/rustfmt.vim:237
Called 6 times
Total time:   0.009717
 Self time:   0.001177

count  total (s)   self (s)
    6              0.000203     if !filereadable(expand("%@"))
                                    return
    6              0.000015     endif
    6   0.008861   0.000511     if rust#GetConfigVar('rustfmt_autosave_if_config_present', 0)
                                    if findfile('rustfmt.toml', '.;') !=# '' || findfile('.rustfmt.toml', '.;') !=# ''
                                        let b:rustfmt_autosave = 1
                                        let b:_rustfmt_autosave_because_of_config = 1
                                    endif
    6              0.000010     else
    6              0.000040         if has_key(b:, '_rustfmt_autosave_because_of_config')
                                        unlet b:_rustfmt_autosave_because_of_config
                                        unlet b:rustfmt_autosave
    6              0.000008         endif
    6              0.000010     endif
                            
    6   0.000291   0.000102     if !rust#GetConfigVar("rustfmt_autosave", 0)
    6              0.000012         return
                                endif
                            
                                call s:RunRustfmt(s:RustfmtCommand(), '', v:true)

FUNCTION  GetRustIndent()
    Defined: /usr/share/nvim/runtime/indent/rust.vim:96
Called 18 times
Total time:   0.028473
 Self time:   0.018451

count  total (s)   self (s)
                                " Starting assumption: cindent (called at the end) will do it right
                                " normally. We just want to fix up a few cases.
                            
   18              0.000471     let line = getline(a:lnum)
                            
   18              0.000338     if has('syntax_items')
   18              0.001916         let synname = synIDattr(synID(a:lnum, 1, 1), "name")
   18              0.000121         if synname ==# "rustString"
                                        " If the start of the line is in a string, don't change the indent
                                        return -1
   18              0.000617         elseif synname =~? '\(Comment\|Todo\)' && line !~# '^\s*/\*'  " not /* opening line
                                        if synname =~? "CommentML" " multi-line
                                            if line !~# '^\s*\*' && getline(a:lnum - 1) =~# '^\s*/\*'
                                                " This is (hopefully) the line after a /*, and it has no
                                                " leader, so the correct indentation is that of the
                                                " previous line.
                                                return GetRustIndent(a:lnum - 1)
                                            endif
                                        endif
                                        " If it's in a comment, let cindent take care of it now. This is
                                        " for cases like "/*" where the next line should start " * ", not
                                        " "* " as the code below would otherwise cause for module scope
                                        " Fun fact: "  /*\n*\n*/" takes two calls to get right!
                                        return cindent(a:lnum)
   18              0.000028         endif
   18              0.000031     endif
                            
                                " cindent gets second and subsequent match patterns/struct members wrong,
                                " as it treats the comma as indicating an unfinished statement::
                                "
                                " match a {
                                "     b => c,
                                "         d => e,
                                "         f => g,
                                " };
                            
                                " Search backwards for the previous non-empty line.
   18              0.000210     let prevlinenum = prevnonblank(a:lnum - 1)
   18   0.010020   0.000651     let prevline = s:get_line_trimmed(prevlinenum)
   18              0.000485     while prevlinenum > 1 && prevline !~# '[^[:blank:]]'
                                    let prevlinenum = prevnonblank(prevlinenum - 1)
                                    let prevline = s:get_line_trimmed(prevlinenum)
   18              0.000054     endwhile
                            
                                " A standalone '{', '}', or 'where'
   18              0.000356     let l:standalone_open = line =~# '\V\^\s\*{\s\*\$'
   18              0.000377     let l:standalone_close = line =~# '\V\^\s\*}\s\*\$'
   18              0.000273     let l:standalone_where = line =~# '\V\^\s\*where\s\*\$'
   18              0.000158     if l:standalone_open || l:standalone_close || l:standalone_where
                                    " ToDo: we can search for more items than 'fn' and 'if'.
    3              0.000281         let [l:found_line, l:col, l:submatch] = searchpos('\<\(fn\)\|\(if\)\>', 'bnWp')
    3              0.000006         if l:found_line !=# 0
                                        " Now we count the number of '{' and '}' in between the match
                                        " locations and the current line (there is probably a better
                                        " way to compute this).
                                        let l:i = l:found_line
                                        let l:search_line = strpart(getline(l:i), l:col - 1)
                                        let l:opens = 0
                                        let l:closes = 0
                                        while l:i < a:lnum
                                            let l:search_line2 = substitute(l:search_line, '\V{', '', 'g')
                                            let l:opens += strlen(l:search_line) - strlen(l:search_line2)
                                            let l:search_line3 = substitute(l:search_line2, '\V}', '', 'g')
                                            let l:closes += strlen(l:search_line2) - strlen(l:search_line3)
                                            let l:i += 1
                                            let l:search_line = getline(l:i)
                                        endwhile
                                        if l:standalone_open || l:standalone_where
                                            if l:opens ==# l:closes
                                                return indent(l:found_line)
                                            endif
                                        else
                                            " Expect to find just one more close than an open
                                            if l:opens ==# l:closes + 1
                                                return indent(l:found_line)
                                            endif
                                        endif
    3              0.000002         endif
   18              0.000032     endif
                            
                                " A standalone 'where' adds a shift.
   18              0.000411     let l:standalone_prevline_where = prevline =~# '\V\^\s\*where\s\*\$'
   18              0.000091     if l:standalone_prevline_where
                                    return indent(prevlinenum) + 4
   18              0.000029     endif
                            
                                " Handle where clauses nicely: subsequent values should line up nicely.
   18              0.000411     if prevline[len(prevline) - 1] ==# "," && prevline =~# '^\s*where\s'
                                    return indent(prevlinenum) + 6
   18              0.000029     endif
                            
   18              0.000237     let l:last_prevline_character = prevline[len(prevline) - 1]
                            
                                " A line that ends with '.<expr>;' is probably an end of a long list
                                " of method operations.
   18              0.000377     if prevline =~# '\V\^\s\*.' && l:last_prevline_character ==# ';'
                                    call cursor(a:lnum - 1, 1)
                                    let l:scope_start = searchpair('{\|(', '', '}\|)', 'nbW', 's:is_string_comment(line("."), col("."))')
                                    if l:scope_start != 0 && l:scope_start < a:lnum
                                        return indent(l:scope_start) + 4
                                    endif
   18              0.000030     endif
                            
   18   0.001647   0.000994     if l:last_prevline_character ==# "," && s:get_line_trimmed(a:lnum) !~# '^\s*[\[\]{})]' && prevline !~# '^\s*fn\s' && prevline !~# '([^()]\+,$' && s:get_line_trimmed(a:lnum) !~# '^\s*\S\+\s*=>'
                                    " Oh ho! The previous line ended in a comma! I bet cindent will try to
                                    " take this too far... For now, let's normally use the previous line's
                                    " indent.
                            
                                    " One case where this doesn't work out is where *this* line contains
                                    " square or curly brackets; then we normally *do* want to be indenting
                                    " further.
                                    "
                                    " Another case where we don't want to is one like a function
                                    " definition with arguments spread over multiple lines:
                                    "
                                    " fn foo(baz: Baz,
                                    "        baz: Baz) // <-- cindent gets this right by itself
                                    "
                                    " Another case is similar to the previous, except calling a function
                                    " instead of defining it, or any conditional expression that leaves
                                    " an open paren:
                                    "
                                    " foo(baz,
                                    "     baz);
                                    "
                                    " if baz && (foo ||
                                    "            bar) {
                                    "
                                    " Another case is when the current line is a new match arm.
                                    "
                                    " There are probably other cases where we don't want to do this as
                                    " well. Add them as needed.
    1              0.000013         return indent(prevlinenum)
   17              0.000027     endif
                            
   17              0.000183     if !has("patch-7.4.355")
                                    " cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
                                    "
                                    " static FOO : &'static [bool] = [
                                    " true,
                                    "	 false,
                                    "	 false,
                                    "	 true,
                                    "	 ];
                                    "
                                    "	 uh oh, next statement is indented further!
                            
                                    " Note that this does *not* apply the line continuation pattern properly;
                                    " that's too hard to do correctly for my liking at present, so I'll just
                                    " start with these two main cases (square brackets and not returning to
                                    " column zero)
                            
                                    call cursor(a:lnum, 1)
                                    if searchpair('{\|(', '', '}\|)', 'nbW', 's:is_string_comment(line("."), col("."))') == 0
                                        if searchpair('\[', '', '\]', 'nbW', 's:is_string_comment(line("."), col("."))') == 0
                                            " Global scope, should be zero
                                            return 0
                                        else
                                            " At the module scope, inside square brackets only
                                            "if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
                                            if line =~# "^\\s*]"
                                                " It's the closing line, dedent it
                                                return 0
                                            else
                                                return &shiftwidth
                                            endif
                                        endif
                                    endif
   17              0.000024     endif
                            
                                " Fall back on cindent, which does it mostly right
   17              0.002358     return cindent(a:lnum)

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:15
Called 35 times
Total time:   0.160763
 Self time:   0.156717

count  total (s)   self (s)
   35              0.000424     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
   35              0.000063     endif
                            
   35              0.000346     let s = expand("<amatch>")
   35              0.000120     if s != ""
   35              0.000406       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
   35              0.000039       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   70              0.000592       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   35   0.157318   0.153272         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   70              0.000263       endfor
   35              0.000060     endif

FUNCTION  <SNR>35_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:44
Called 1254 times
Total time:   0.521215
 Self time:   0.465169

count  total (s)   self (s)
 1254              0.017312   if !exists("w:matchparen_ids")
    2              0.000007     let w:matchparen_ids = []
 1254              0.002757   endif
                              " Remove any previous match.
 1254   0.065308   0.021827   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
 1254              0.011988   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
 1254              0.001274   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
 1254              0.008467   let c_lnum = line('.')
 1254              0.006451   let c_col = col('.')
 1254              0.003287   let before = 0
                            
 1254              0.007796   let text = getline(c_lnum)
 1254              0.042900   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
 1254              0.006102   if empty(matches)
                                let [c_before, c] = ['', '']
 1254              0.001712   else
 1254              0.011798     let [c_before, c] = matches[1:2]
 1254              0.001734   endif
 1254              0.037911   let plist = split(&matchpairs, '.\zs[:,]')
 1254              0.009022   let i = index(plist, c)
 1254              0.004445   if i < 0
                                " not found, in Insert mode try character before the cursor
 1102              0.008083     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  397              0.003005       let before = strlen(c_before)
  397              0.001593       let c = c_before
  397              0.002808       let i = index(plist, c)
 1102              0.001383     endif
 1102              0.002216     if i < 0
                                  " not found, nothing to do
 1094              0.002462       return
    8              0.000014     endif
  160              0.000228   endif
                            
                              " Figure out the arguments for searchpairpos().
  160              0.000588   if i % 2 == 0
   22              0.000095     let s_flags = 'nW'
   22              0.000108     let c2 = plist[i + 1]
  138              0.000200   else
  138              0.000552     let s_flags = 'nbW'
  138              0.000512     let c2 = c
  138              0.000828     let c = plist[i - 1]
  160              0.000207   endif
  160              0.000546   if c == '['
   30              0.000088     let c = '\['
   30              0.000090     let c2 = '\]'
  160              0.000196   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  160              0.000483   if before > 0
    8              0.000083     let has_getcurpos = exists("*getcurpos")
    8              0.000025     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    8              0.000063       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
    8              0.000011     endif
    8              0.000082     call cursor(c_lnum, c_col - before)
  160              0.000221   endif
                            
  160              0.002280   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
  160              0.000214   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
  160              0.001954     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
  160              0.000367     try
  160   0.047484   0.044010       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
  160              0.000325     endtry
  160              0.000244   endif
                            
                              " Limit the search to lines visible in the window.
  160              0.001451   let stoplinebottom = line('w$')
  160              0.000998   let stoplinetop = line('w0')
  160              0.000575   if i % 2 == 0
   22              0.000124     let stopline = stoplinebottom
  138              0.000191   else
  138              0.000944     let stopline = stoplinetop
  160              0.000211   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  160              0.001099   if mode() == 'i' || mode() == 'R'
  106              0.001784     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   54              0.000046   else
   54              0.000431     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  160              0.000231   endif
  160              0.000285   try
  160   0.106004   0.096913     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
  160              0.000383   endtry
                            
  160              0.000580   if before > 0
    8              0.000025     if has_getcurpos
    8              0.000083       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
    8              0.000011     endif
  160              0.000191   endif
                            
                              " If a match is found setup match highlighting.
  160              0.001210   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  151              0.000539     if s:has_matchaddpos
  151              0.004395       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
  151              0.000201     endif
  151              0.000701     let w:paren_hl_on = 1
  160              0.000288   endif

FUNCTION  <SNR>59_get_line_trimmed()
    Defined: /usr/share/nvim/runtime/indent/rust.vim:41
Called 20 times
Total time:   0.010022
 Self time:   0.010022

count  total (s)   self (s)
                                " Get the line and remove a trailing comment.
                                " Use syntax highlighting attributes when possible.
                                " NOTE: this is not accurate; /* */ or a line continuation could trick it
   20              0.000209     let line = getline(a:lnum)
   20              0.000178     let line_len = strlen(line)
   20              0.000217     if has('syntax_items')
                                    " If the last character in the line is a comment, do a binary search for
                                    " the start of the comment.  synID() is slow, a linear search would take
                                    " too long on a long line.
   20              0.006978         if synIDattr(synID(a:lnum, line_len, 1), "name") =~? 'Comment\|Todo'
                                        let min = 1
                                        let max = line_len
                                        while min < max
                                            let col = (min + max) / 2
                                            if synIDattr(synID(a:lnum, col, 1), "name") =~? 'Comment\|Todo'
                                                let max = col
                                            else
                                                let min = col + 1
                                            endif
                                        endwhile
                                        let line = strpart(line, 0, min - 1)
   20              0.000039         endif
   20              0.000810         return substitute(line, "\s*$", "", "")
                                else
                                    " Sorry, this is not complete, nor fully correct (e.g. string "//").
                                    " Such is life.
                                    return substitute(line, "\s*//.*$", "", "")
                                endif

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:14
Called 35 times
Total time:   0.046201
 Self time:   0.046075

count  total (s)   self (s)
   35              0.000306     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
   35              0.000039     endif
   35              0.000272     let s = expand("<amatch>")
   35              0.000119     if s != ""
   35              0.000126       if exists("b:did_indent")
                            	unlet b:did_indent
   35              0.000035       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   70              0.000457       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
   35   0.043948   0.043822         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   70              0.000176       endfor
   35              0.000051     endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
 1254   0.521215   0.465169  <SNR>35_Highlight_Matching_Pair()
   35   0.160763   0.156717  <SNR>1_LoadFTPlugin()
    1   0.113798   0.000178  rustfmt#DetectVersion()
   35   0.102379   0.091637  <SNR>55_SynSet()
   35   0.046201   0.046075  <SNR>2_LoadIndent()
 1264   0.043885             <SNR>35_Remove_Matches()
   18   0.028473   0.018451  GetRustIndent()
   20   0.010022             <SNR>59_get_line_trimmed()
    6   0.009717   0.001177  rustfmt#PreWrite()
   12   0.000433             rust#GetConfigVar()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 1254   0.521215   0.465169  <SNR>35_Highlight_Matching_Pair()
   35   0.160763   0.156717  <SNR>1_LoadFTPlugin()
   35   0.102379   0.091637  <SNR>55_SynSet()
   35   0.046201   0.046075  <SNR>2_LoadIndent()
 1264              0.043885  <SNR>35_Remove_Matches()
   18   0.028473   0.018451  GetRustIndent()
   20              0.010022  <SNR>59_get_line_trimmed()
    6   0.009717   0.001177  rustfmt#PreWrite()
   12              0.000433  rust#GetConfigVar()
    1   0.113798   0.000178  rustfmt#DetectVersion()

